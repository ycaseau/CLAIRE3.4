//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| call.cl                                                     |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// -----------------------------------------------------------------
// This file holds the definition of functional calls in CLAIRE
// -----------------------------------------------------------------`

// *********************************************************************
// * Contents                                                          *
// *      Part 1: the basic object messages                            *
// *      Part 2: Basic structures                                     *
// *      Part 3: Specialized structures                               *
// *      Part 4: Functions on instructions                            *
// *********************************************************************

// *********************************************************************
// *      Part 1: the basic object messages                            *
// *********************************************************************

// contains the last message that was evaluated
iClaire/LastCall:any := unknown

// messages in CLAIRE are called calls --------------------------------
//
Call[selector,args] <: Control_structure(selector:property,args:list)
Call*[selector,args] <: Call()
Call+[selector,args] <: Call()

self_print(self:Call) : void
 -> (let %l := pretty.index,
         %s := self.selector,
         %a := self.args in
       (if (%s % operation & length(%a) = 2)
           printf("~I~I ~S ~I~I", (pretty.index :+ 2), printe(%a[1], %s),
                  %s, lbreak(), printe(%a[2], %s))
        else if (%s = nth)
          (if (length(%a) = 3) printf("~I[~S,~S]", printexp(%a[1], false), %a[2], %a[3])
           else if (length(%a) = 1) printf("~I[]",printexp(%a[1], false))
           else printf("~I[~I]", printexp(%a[1], false),
                       (if (length(%a) = 2) print(%a[2])))) // v3.0.70
        else if (%s = nth= & length(%a) >= 3)
           let a := %a[3],
               o := (case a (Call a.selector)) in
             (if (length(%a) = 4)
                 printf("~I[~S,~S] := ~I~S", printexp(%a[1], false),
                        %a[2], a, lbreak(2), %a[4])
              else if sugar?(%a[1], %a[2], o, (case a (Call a.args[1])))
                 printf("~S[~S] :~S ~I~S", %a[1], %a[2], o, lbreak(2),
                        a.args[2])
              else printf("~S[~S] := ~I~S", %a[1], %a[2], lbreak(2), a))
        else if (%s = assign & %a[1] % property)
           let a := %a[3],
               o := (case a (Call a.selector)) in
             (if sugar?(%a[1], %a[2], o, (case a (Call a.args[1])))
                 printf("~S(~S) :~S ~I~S", %a[1], %a[2], o, lbreak(2),
                        a.args[2])
              else printf("~S(~S) := ~I~S", %a[1], %a[2], lbreak(2), %a[3]))
        else if (%s = add & %a[1] % property)
           printf("~S(~S) :add ~I~S", %a[1], %a[2], lbreak(2), %a[3])
        else if (%s = delete & %a[1] % property)
           printf("~S(~S) :delete ~I~S", %a[1], %a[2], lbreak(2), %a[3])
        else if (%a[1] = system & length(%a) = 1) printf("~S()", %s)
        else printf("~S(~I~I)", %s, set_level(), printbox(%a)),
        pretty.index := %l))

self_print(self:Call+) : any
 -> printf("~I.~S", printexp(self.args[1], true), self.selector)

self_eval(self:Call) : any
 -> (let start := mClaire/index!(),
         p := self.selector in
       (if (system.Core/debug! >= 0) LastCall := self,
        for x in self.args mClaire/push!(eval(x)),
        let rx := eval_message(p, Core/find_which(p, start,
                                                  owner(mClaire/get_stack(start))),
                               start, true) in
          (if (system.Core/debug! >= 0) LastCall := self,
           rx)))

self_eval(self:Call+) : any
 -> (let p := self.selector,
         x := eval(self.args[1]),
         s := (p @ owner(x)) in
       (if not(owner(s) = slot)
            selector_error(selector = p, arg = list(x))  // v3.0.72
        else let z := slot_get(x, (s as slot).index, (s as slot).mClaire/srange) in
               (if (known?(z) | z % s.range)
                   let n := system.Core/trace! in
                     (if (n > 0 &
                          ((p.Core/trace! + system.verbose) > 4 |
                           n = system.Core/step!))
                         (put(Core/trace!, system, 0),
                          printf("read: ~S(~S) = ~S\n", p, x, z),
                          put(Core/trace!, system, n)),
                      z)
                else read_slot_error(arg = x, wrong = p))))

// recursive printing of bicall
//
printe(self:any,s:property) : void
 -> (if (case self
          (Call (self.selector % operation & length(self.args) = 2)))
        (if true printf("(~S)", self) else printexp(self, true))
     else printexp(self, true))

// tells if the sugar :op can be used
//
sugar?(x:any,x2:any,o:any,a:any) : boolean
 -> (case o
      (operation case x
                 (property
                    case a (Call (x = a.selector & a.args[1] = x2), any false)),
      (Variable U global_variable) x = a,
       any case a
                      (Call
                         (a.selector = nth & a.args[1] = x &
                          a.args[2] = x2),
                       any false)))

// *********************************************************************
// *      Part 2: Basic structures                                     *
// *********************************************************************
// ------------------ assignment ---------------------------------------
// <-(var V, arg E) where V is a variable (and therefore NOT a global_variable)
//
// the var slot is filled with a real variable later.

Assign <: Basic_instruction(var:any,arg:any)
self_print(self:Assign) : void
 -> (let a := self.arg,
         o := (case a (Call a.selector)) in
       (if sugar?(self.var, {}, o, (case a (Call a.args[1])))
           printf("~S :~S ~I~I", self.var, o, lbreak(2),
                  printexp(a.args[2], true))
        else printf("~S := ~I~I", self.var, lbreak(2), printexp(a, true)),
        pretty.index :- 2))

self_eval(self:Assign) : any
 -> (if (self.var % Variable)
        write_value((self.var as Variable), eval(self.arg))
     else error("[101] ~S is not a variable", self.var))

// global variables
//
Gassign <: Basic_instruction(var:global_variable,arg:any)
self_print(self:Gassign) : void
 -> (let a := get(arg, self),
         o := (case a (Call a.selector)) in
       (if sugar?(self.var, {}, o, (case a (Call a.args[1])))
           printf("~S :~S ~I~S", self.var, o, lbreak(2), a.args[2])
        else printf("~S := ~I~S", self.var, lbreak(2), a),
        pretty.index :- 2))

self_eval(self:Gassign) : any
 -> (let v := self.var in write_value(v, eval(self.arg)))

//--------------- BOOLEAN OPERATIONS ---------------------------------
// "and" is strictly boolean and is based on short-circuit evaluation.
//
And <: Control_structure(args:list)
self_print(self:And) : void -> printf("(~I)", printbox(self.args, " & "))
self_eval(self:And) : any
 -> not( (for x in self.args (if not(eval(x)) break(true)) ))

// or expression
//
Or <: Control_structure(args:list)
self_print(self:Or) : void -> printf("(~I)", printbox(self.args, " | "))
self_eval(self:Or) : any
 -> (if (for x in self.args (if eval(x) break(true))) true else false)

// ----------------- an anti-evaluator ---------------------------------
//
Quote <: Basic_instruction(arg:any)
self_print(self:Quote) : void  -> printf("quote(~S)", self.arg)
self_eval(self:Quote) : any -> self.arg

// *********************************************************************
// *      Part 3: Specialized structures                               *
// *********************************************************************
// optimized_instruction is the set of optimized messages.
// These are the forms produced by the optimizer. They correspond to basic
// kinds of evaluation.
//
Optimized_instruction <: Complex_instruction()

// This is how a call to a compiled method can be compiled.
// We use the C external function
//
Call_method <: Optimized_instruction(arg:method,args:list)

self_print(self:Call_method) : void
  -> printf("~S(~I)", self.arg, princ(self.args))

self_eval(self:Call_method) : any
  -> (let start := mClaire/index!(), Cprop := self.arg in
        (for x in self.args mClaire/push!(eval(x)),
         execute(Cprop, start, true)))

// same thing with one only argument: we do not use the stack
//
(Call_method1 <: Call_method(),
 self_eval(self:Call_method1) : any
  -> (let f := self.arg,l := self.args in funcall(f, eval(l[1]))) )

// same thing with two arguments
//
(Call_method2 <: Call_method(),
 self_eval(self:Call_method2) : any
  -> (let f := self.arg,
          l := self.args in
        funcall(f, eval(l[1]), eval(l[2]))) )

// an instruction to read a slot
//
Call_slot <: Optimized_instruction(selector:slot,arg:any,test:boolean)
self_print(self:Call_slot) : void
 -> printf("~S(~S)", self.selector, self.arg)
self_eval(self:Call_slot) : any -> get(self.selector, eval(self.arg))

// an instruction to read an array
// selector is an exp with type array, arg is an exp with type integer, and test
// contains the inferred member_type of the array
//
Call_array <: Optimized_instruction(selector:any,arg:any,test:any)
self_print(self:Call_array) : void
 -> printf("~S[~S]", self.selector, self.arg)
self_eval(self:Call_array) : any ->
   nth(eval(self.selector) as array,eval(self.arg) as integer)

// an instruction to read a table
//
Call_table <: Optimized_instruction(selector:table,arg:any,test:boolean)
self_print(self:Call_table) : void
 -> printf("~S[~S]", self.selector, self.arg)
self_eval(self:Call_table) : any ->
  (if self.test self.selector[eval(self.arg)]
   else get(self.selector, eval(self.arg)))

// an instruction to write a slot
// the structure is complex: see ocall.cl
//
Update <: Optimized_instruction(selector:any,
                                arg:any,
                                value:any,
                                var:any)
self_print(self:Update) : void
 -> printf("~S(~S) := ~S", self.selector, self.var.arg, self.value)
self_eval(self:Update) : any
 -> let s := self.selector in
      (case s
        (property put(s, eval(self.var.arg), eval(self.value)),
         table s[eval(self.var.arg)] := eval(self.value)),
       unknown)

// ------------------ SUPER: a jump in the set lattice ---------------
// A "super" allows one to execute a message as if the type of the receiver
// was a given abstract_class.
// However we require that the receiver be in the specified abstract_class.
// The form of the super is: SELECTOR@ABSTRACT_CLASS(RECEIVER , ...)
//
Super <: Control_structure(selector:property,cast_to:type,args:list)

self_print(self:Super) : void
 -> (let %l := pretty.index,
         %s := self.selector,
         %a := self.args in
       (printf("~S@~S(~I~I)", self.selector, self.cast_to, set_level(),
               printbox(%a)),
        pretty.index := %l))

self_eval(self:Super) : any
 -> (let start := mClaire/index!(),
         t := self.cast_to,
         c := class!(t),
         p := self.selector in
       (for x in self.args mClaire/push!(eval(x)),
        eval_message(p, Core/find_which(c, p.Core/definition, start, mClaire/index!()),
                     start, true)))

//--------------- comments ------------------------------------------
// the cast is the new form of simple super
//
Cast <: Basic_instruction(arg:any,set_arg:type)

self_print(x:Cast) : void
 -> printf("~I as ~I", printexp(x.arg, false), printexp(x.set_arg, false))

self_eval(self:Cast) : any
 -> let x := eval(self.arg), y := self.set_arg in
      (if (case y (Param ((y.arg = list | y.arg = set) & y.args[1] % set)))
          Core/check_in(x, bag, ((y as Param).args[1] as set)[1])
       else Core/check_in(x,y))                // v3.3.16

// ----------------- return from a loop --------------------------------
//
// return_error is an exception that is handled by the "for" family
// of structures
//
Return <: Basic_instruction(arg:any)

self_print(self:Return) : void
 -> printf("break(~I~S~I)", (pretty.index :+ 2), self.arg,
           (pretty.index :- 2))
self_eval(self:Return) : any -> return_error(arg = eval(self.arg))

// ****************************************************************
// *       Part 4: Miscellaneous on instructions                  *
// ****************************************************************
// substitute any variable with same name as x with the value val
[substitution(self:any,x:Variable,val:any) : any
 -> case self
      (Variable (if (self.mClaire/pname = x.mClaire/pname) val else self),
       bag (for i in (1 .. length(self))
              (if (self[i] % Variable | self[i] % unbound_symbol)
                  self[i] := substitution(self[i], x, val)
               else substitution(self[i], x, val)),
            self),
       unbound_symbol (if (self.name = x.mClaire/pname) val else self),
       Instruction (for s in owner(self).slots
                      let y := get(s, self) in
                         (if (y % Variable | y % unbound_symbol)
                             put(s, self, substitution(y, x, val))
                          else substitution(y, x, val)),
                    self),
       any self) ]

// count the number of occurrences of x
[occurrence(self:any,x:Variable) : integer
 -> case self
      (Variable (if (self.mClaire/pname = x.mClaire/pname) 1 else 0),
       bag let n := 0 in
             (for i in (1 .. length(self)) n :+ occurrence(self[i], x), n),
       unbound_symbol (if (self.name = x.mClaire/pname) 1 else 0),
       Instruction let n := 0 in
                     (for s in owner(self).slots
                        n :+ occurrence(get(s, self), x),
                      n),
       any 0) ]

// makes a (deep) copy of the instruction self
//
instruction_copy(self:any) : any
 -> (case self
      (bag let l := copy(self) in
             (for i in (1 .. length(self)) l[i] := instruction_copy(self[i]),
              l),
       Variable self,
       Instruction let o := copy(self) in
                     (for s in owner(self).slots
                        put(s, o, instruction_copy(get(s, self))),
                      o),
       any self))




//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| control.cl                                                  |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// *********************************************************************
// *     Part 1: If, Do, Let                                           *
// *     Part 2: set control structures                                *
// *     Part 3: other control structures                              *
// *     Part 4: the constructs                                        *
// *********************************************************************

// *********************************************************************
// *     Part 1: If, Do, Let                                           *
// *********************************************************************

//--------------- the IF --------------------------------------------
If <: Control_structure(test:any,arg:any,other:any = false)

self_print(self:If) : void
 -> printf("(~I~I~I)", (pretty.index :+ 1), printstat(self),
           (pretty.index :- 1))

printstat(self:If) : void
 -> printf("if ~I ~I~I~I", (printexp(self.test, false), checkfar()),
           printif(self.arg), (pretty.index :- 3), printelse(self))

printif(self:any) : void
 -> (pretty.index :+ 3,
     if pretty.mClaire/pbreak
        let b_index := mClaire/buffer_length(),
            %l := pretty.index in
          (pretty.mClaire/pbreak := false,
           try print(self) catch much_too_far {},
         pretty.mClaire/pbreak := true,
         if short_enough(mClaire/buffer_length()) {}
         else (mClaire/buffer_set_length(b_index),
               pretty.index := %l,
               lbreak(),
               print(self)))
     else print(self))

printelse(self:If) : void
 -> (let e := get(other, self) in
       case e
        (If printf(" ~Ielse if ~I ~I~I~I", lbreak(),
                   printexp(e.test, false), printif(e.arg),
                   (pretty.index :- 3), printelse(e)),
         any (if (e != nil)
                let %l := pretty.index in
                  (printf(" ~Ielse ~I~S", lbreak(), set_level(1), e),
                   pretty.index := %l))))

// notice that the eval(test) is not a boolean thus the compiler will add
// something
// TODO: check that is is not too slow (may use a constant for _oid_(true))
self_eval(self:If) : any
 -> let x := eval(self.test) in
      (if (x = true) eval(self.arg)
       else if (x = false) eval(self.other)
       else if x eval(self.arg)
       else eval(self.other))

//--------------------- block structure------------------------------
Do[args] <: Control_structure(args:list)

self_print(self:Do) : void
 -> (let %l := pretty.index in
       (printf("("),
        set_level(1),
        printdo(self.args, true),
        pretty.index := %l))

printdo(l:list,clo:boolean) : void
 -> (let n := length(l) in
       for x in l
         (case x (If printstat(x), any print(x)),
          n :- 1,
          if (n = 0) (if clo princ(")"))
          else (printf(", "), lbreak())))

printblock(x:any) : void
 -> (case x (Do printdo(x.args, false), If printstat(x), any print(x)))

self_eval(self:Do) : any
 -> (let res:any := {} in (for %x in self.args res := eval(%x), res))

// ----------------- lexical variable definition -----------------------
Let <: Instruction_with_var(value:any,arg:any)

self_print(self:Let) : void
 -> (let %l := pretty.index in
       (set_level(1),
        printf("let ~I := ~I~I", ppvariable(self.var),
               printexp(get(value, self), false), printbody(self)),
        pretty.index := %l))

printbody(self:Let) : void
 -> (let a := self.arg in
       case a
        (Let printf(",~I~I := ~I~I~I", lbreak(4), ppvariable(a.var),
                    printexp(get(value, a), false), (pretty.index :- 4),
                    printbody(a)),
         any printf(" in ~I~S", lbreak(2), a)))

self_eval(self:Let) : any
 -> (let val := eval(self.value),
         n := system.Core/trace! in
       (if (n > 0 & n = system.Core/step!)
           (put(Core/trace!, system, 0),
            printf("start: let ~S := ~S ...\n", self.var, val),
            put(Core/trace!, system, n)),
        write_value@Variable(self.var, val),
        eval(self.arg)))

// a when is a special Let that filters out the unknown value !
//
When <: Let(other:any = unknown)
self_print(self:When) : void
 -> (let %l := pretty.index in
       (set_level(1),
        printf("when ~I := ~I in ~I~S", ppvariable(self.var),
               printexp(get(value, self), false), lbreak(2), self.arg),
        if known?(other, self)
           printf(" ~Ielse ~I~S", lbreak(), set_level(1), self.other),
        pretty.index := %l))

self_eval(self:When) : any
 -> (let val := eval(self.value),
         n := system.Core/trace! in
       (if (n > 0 & n = system.Core/step!)
           (put(Core/trace!, system, 0),
            printf("start: when ~S := ~S ...\n", self.var, val),
            put(Core/trace!, system, n)),
        if (val != unknown)
           (write_value@Variable(self.var, val), eval(self.arg))
        else eval(self.other)))

// two special forms of Let:
// Let+(v,r(x),(r(x) := y),Let(v2,e,(r(x) := v,v2)))    <=>  let r(x) = y in e
// Let*(v,f(),Let(v1,v[1],...(Let(vn,v[n],e))   <=> let (v1,v2,...vn) := f() in e
//
Let+ <: Let()
Let* <: Let()

//note: the Let* is also used for multi-assignments
// Let*(v,f(),(v1 := v[1], v2 := v[2], ...))   <=>  (v1,v2,...vn) := f()
//
self_print(self:Let+) : void
 -> (let %l := pretty.index,
         l := (self.arg as Do).args in
       (set_level(1),
        printf("let ~I := ~I in ~I~S", printexp(self.value, false),
               printexp(l[1].args[3], false), lbreak(2), (l[2] as Let).value),
        pretty.index := %l))

self_print(self:Let*) : void
 -> (let %l := pretty.index,
         l := self.arg in
       (set_level(1),
        if (l % Let)
           printf("let (~I) := ~I~I",
                  (while true
                     (ppvariable(l.var),
                      let lnext := l.arg in
                        (if (case lnext
                              (Let
                                 (lnext.value % Call &
                                  lnext.value.args[1] = self.var)))
                            (princ(","), l := lnext)
                         else break(true)))),
                  printexp(get(value, self), false), printbody(l))
        else printf("(~I) := ~I",
                    (let %f := true in
                       for %a in l.args
                         (if %f %f := false
                          else princ(","),
                          ppvariable(%a.var))),
                    printexp(get(value, self), false)),
        pretty.index := %l))

// *********************************************************************
// *     Part 2: set control structures                                *
// *********************************************************************
Iteration <: Instruction_with_var(set_arg:any,arg:any)
iterate :: property()
Iterate :: property()

// for is the simplest evaluation loop
//
For <: Iteration()
self_print(self:For) : void
 -> printf("for ~I in ~I ~I", ppvariable(self.var),
           (let %l := pretty.index in
              (set_level(),
               printexp(self.set_arg, false),
               pretty.index := %l)),
           (pretty.index :+ 2,
            lbreak(),
            print(self.arg),
            pretty.index :- 2))

self_eval(self:For) : any
 -> (let x := eval(self.set_arg),
         n := system.Core/trace! in
       (if (n > 0 & n = system.Core/step!)
           (put(Core/trace!, system, 0),
            printf("start: for ~S in ~S ...\n", self.var, x),
            put(Core/trace!, system, n)),
        try case x
         (class for y in x.descendents
                 for z in y.instances
                   (write_value(self.var, z), eval(self.arg)),
          array let n := length(x) in
                  for z in list{nth_get(x,i) | i in (1 .. n)}
                    (write_value(self.var, z), eval(self.arg)),
          Interval for y in (x.arg1 .. x.arg2)
                      (write_value(self.var, y), eval(self.arg)),
          collection for y in x (write_value(self.var, y), eval(self.arg)),
          any error("[136] ~S is not a collection !", x))
        catch return_error system.exception!.arg))

// [collect VAR in SET_EXPR, ...] is the same as a "for", but returns the list of values
//
Collect <: Iteration(of:type)

self_print(self:Collect) : void
 -> printf("list{ ~I | ~I~I in ~I}",
           (pretty.index :+ 2, printexp(self.arg, false)),
           lbreak(),
           ppvariable(self.var),
           (let %l := pretty.index in
              (set_level(),
               printexp(self.set_arg, false),
               pretty.index := %l - 2)))

self_eval(self:Collect) : any
 -> (let x := eval(self.set_arg),
         res:list := list() in
       (case x
         (class for y in x.descendents
                 for z in y.instances
                   (write_value(self.var, z), res :add eval(self.arg)),
          any for y in x
               (write_value(self.var, y), res :add eval(self.arg))),
        if known?(of,self)
          (when x := some(x in res | not(x % self.of)) in   // v3.1.06
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(res,self.of)),
        res))

// this is a set image version, that produces a set
//
Image <: Iteration(of:type)

self_print(self:Image) : void
 -> printf("{ ~I | ~I~I in ~I}",
           (pretty.index :+ 2, printexp(self.arg, false)), lbreak(),
           ppvariable(self.var),
           (let %l := pretty.index in
              (set_level(),
               printexp(self.set_arg, false),
               pretty.index := %l - 2)))

self_eval(self:Image) : any
 -> (let x := eval(self.set_arg),
         res:set := set() in
       (for y in x (write_value(self.var, y), res :add eval(self.arg)),
        if known?(of,self)
          (when x := some(x in res | not(x % self.of)) in   // v3.1.06
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(res,self.of)),
       res))

// [select VAR in SET_EXPR, ...] is the same as a "for" but returns the subset of
//  members that produce a true value
//
Select <: Iteration(of:type)
self_print(self:Select) : void
 -> printf("{ ~I in ~I | ~I}", ppvariable(self.var),
           (let %l := pretty.index in
              (set_level(),
               printexp(self.set_arg, false),
               pretty.index := %l)),
           (lbreak(2), print(self.arg), pretty.index :- 2))

self_eval(self:Select) : any
 -> (let x := eval(self.set_arg),
         res:set := (case x (set empty(x), any set())) in
       (case x
         (class for y in x.descendents
                 for z in y.instances
                   (write_value(self.var, z),
                    if (eval(self.arg) != false) res :add z),
          any for y in x
               (write_value(self.var, y), if (eval(self.arg) != false) res :add y)),
        if known?(of,self)
          (when x := some(x in res | not(x % self.of)) in   // v3.1.06
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(res,self.of)),
        res))

// [select VAR in SET_EXPR, ...] is the same as a "for" but returns the subset of
//  members that produce a true value
//
Lselect <: Iteration(of:type)

self_print(self:Lselect) : void
 -> printf("list{ ~I in ~I | ~I}", ppvariable(self.var),
           (let %l := pretty.index in
              (set_level(),
               printexp(self.set_arg, false),
               pretty.index := %l)),
           (lbreak(2), print(self.arg), pretty.index :- 2))

self_eval(self:Lselect) : any
 -> (let x := eval(self.set_arg),
         res:list := (case x (list empty(x), any list())) in
       (case x
         (class for y in x.descendents
                 for z in y.instances
                   (write_value(self.var, z),
                    if (eval(self.arg) != false) res :add z),
          any for y in x
               (write_value(self.var, y), if (eval(self.arg) != false) res :add y)),
        if known?(of,self)
          (when x := some(x in res | not(x % self.of)) in   // v3.1.06
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(res,self.of)),
        res))

// Exists is an iteration that checks a condition
// other = true => forall,  other = false => exists, other = unknown => some
Exists <: Iteration(other:any = false)

self_print(self:Exists) : void
 -> (if (self.other = true) princ("forall")
     else if (self.other = false) princ("exists")
     else princ("some"),
     if (self.set_arg = any)
        printf("(~I,~I)", ppvariable(self.var), print(self.arg))
     else printf("(~I in ~I | ~I)", ppvariable(self.var),
                 (let %l := pretty.index in
                    (set_level(),
                     printexp(self.set_arg, false),
                     pretty.index := %l)),
                 (lbreak(2), print(self.arg), pretty.index :- 2)))

self_eval(self:Exists) : any
 -> (let x := eval(self.set_arg),
         b := self.other,
         res:any := b in
       (case x
         (class for y in x.descendents
                 for z in y.instances
                   (write_value(self.var, z),
                    if (eval(self.arg) != false)
                       (if (b != true) break(res := (if b z else true)))
                    else if (b = true) break(res := false)),
          any for y in x
               (write_value(self.var, y),
                if (eval(self.arg) != false)
                   (if (b != true) break(res := (if b y else true)))
                else if (b = true) break(res := false))),
        res))

// *********************************************************************
// *     Part 3: other control structures                              *
// *********************************************************************

// ----------------- case  --------------------------------------
Case <: Control_structure(var:any,args:list)

self_print(self:Case) : void
 -> (printf("case ~S ~I(", self.var, lbreak(1)),
     let n := 1,
         m := length(self.args) in
       (pretty.index :+ 1,
        while (n <= m)
          let %l := pretty.index in
            (printf("~I ~I~I", printexp(self.args[n], false),
                    (if (mClaire/buffer_length() > (pretty.mClaire/width - 50))
                        lbreak(2)
                     else set_level(),
                     print(self.args[n + 1])),
                    (pretty.index := %l,
                     if ((n + 1) != m) printf(", ~I", lbreak()))),
             n :+ 2),
        printf(")"),
        pretty.index :- 2))

[self_eval(self:Case) : any
 -> let truc := eval(self.var),
         flip:boolean := true,
         previous:any := false in
     (if (for x in self.args
          (if flip (flip := false, previous := eval(x))
           else if (truc % previous)
                  (previous := eval(x), break(true))
           else flip := true))
        previous
      else false) ]

// ------------------ WHILE  and UNTIL  -----------------------------
// the "other" while is until, where the first test is skipped
While <: Control_structure(test:any,arg:any,other:boolean = false)

self_print(self:While) : void
 -> (printf("~A ~I ~I~S", (if self.other "until" else "while"),
            printexp(self.test, false), lbreak(2), self.arg),
     pretty.index :- 2)

self_eval(self:While) : any
 -> (let a := self.other,
         b := a in
       try while (b | not(eval(self.test)) = a)
         (b := false, eval(self.arg))
       catch return_error system.exception!.arg)

//-------------- handling errors -----------------------------------
// This is the control structure associated with these errors. Its real
// semantics is defined in the C compiler file
//
Handle <: Control_structure(test:any,arg:any,other:any)

self_print(self:Handle) : void
 -> (printf("try ~S ~Icatch ~S ~S", self.arg, lbreak(0), self.test,
            self.other),
     pretty.index :- 2)

self_eval(self:Handle) : any
 -> (let x := eval(self.test) in
       try eval(self.arg)
       catch x (if (exception!() % return_error) close(exception!())
                else eval(self.other)))     // <yc> 6/98

// *********************************************************************
// *     Part 4: the constructs                                         *
// *********************************************************************

Construct <: Complex_instruction(args:list)

List <: Construct(of:type)
Tuple <: Construct()
Set <: Construct(of:type)
Array <: Construct(of:type)        // v3.2.16   constructor for arrays
Printf <: Construct()
Error <: Construct()
Branch <: Construct()

self_print(self:Construct) : void
 -> (let %l := pretty.index in
       (printf("~A~I(~I~I)",       // v3.2.56-58 add a <type> when needed
               (case self
                 (List "list",
                  Set "set",
                  Tuple "tuple",
                  Printf "printf",
                  Error "error",
                  Trace "trace",
                  Assert "assert",
                  Branch "branch",
                  any string!(self.isa.name))),
               (case self ((List U Set)
                            when %t := get(of,self) in (if (%t != {}) printf("<~S>", %t) ))),
               set_level(), printbox(self.args)),
        pretty.index := %l))

// constructors: how to create a list, a set, a tuple or an array
// note that the constructor is typed
self_eval(self:List) : any
 -> let l := list{ eval(x) | x in self.args} in
      (if known?(of,self)
          (when x := some(x in l | not(x % self.of)) in   // v3.0.72
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(l,self.of))  // v0.01
       else Kernel/cast!(l,{}))      // v3.2

self_eval(self:Set) : any
 -> let s := set!(list{ eval(x) | x in self.args}) in
      (if known?(of,self)
          (when x := some(x in s | not(x % self.of)) in   // v3.0.72
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(s,self.of))   // v0.01
       else Kernel/cast!(s,{}))
       
self_eval(self:Tuple) : any
 -> tuple!(list{ eval(x) | x in self.args})

// v3.2.16 - introduce a nicer way to create an array
self_eval(self:Array) : any
 -> let l := list{ eval(x) | x in self.args} in
      (if known?(of,self)
          (when x := some(x in l | not(x % self.of)) in   // v3.0.72
               range_error(cause = self,arg = x,wrong = self.of),
           Kernel/cast!(l,self.of))   // v0.01
       else Kernel/cast!(l,any),
       array!(l))
       

// Macros are a nice but undocumented feature of CLAIRE. This is deliberate :)
// it is an advanced feature for those who want to expand the language. This
// makes CLAIRE a nice framework for DSL
//
Macro <: Construct()
macroexpand :: property(open = 3)
self_eval(self:Macro) : any -> eval(call(macroexpand,self))


// error produces an exception of type general_error
self_eval(self:Error) : void
 -> (if (not(self.args) | not(self.args[1] % string))
        error("Syntax error: ~S", self),
     let x:general_error := mClaire/new!(general_error) in      // v3.2.26
        (x.mClaire/cause := car(self.args),
         x.arg := list{ eval(x) | x in cdr(self.args)},
         close@exception(x)))

// this is the basic tool for printing in CLAIRE. A complex statement
// is macroexpanded into basic printing instructions
//
[self_eval(self:Printf) : any
 -> let l := self.args,
        s := l[1] in
       (if not(s % string)
           error("[102] the first argument in ~S must be a string", self)
        else let i := 2,
                 n := get(s, '~') in
               (while not(n = 0)
                  let m := s[n + 1] in
                    (if (i > length(l))
                        error("[103] not enough arguments in ~S", self),
                     if (n > 1) princ(substring(s, 1, n - 1)),
                     if ('A' = m) princ(eval(l[i]))
                     else if ('S' = m) print(eval(l[i]))
                     else if ('F' = m)  // v3.4
                        let fv := eval(l[i]),                              // float value
                            p% := false,                                   // print a %
                            j := integer!(nth_get(s,n + 2,n + 2)) - 48 in
                          (if ('%' = s[n + 2]) (p% := true, j := 1, fv :* 100.0)
                           else if (j < 0 | j > 9) error("[189] F requires a single digit integer in ~S",self),
                           if (not(p%) & '%' = s[n + 3]) (p% := true, fv :* 100.0, n :+ 1),
                           mClaire/printFDigit(fv,j),
                           if p% princ("%"),
                           n :+ 1)
                     else if ('I' = m) eval(l[i]),
                     i :+ 1,
                     s := substring(s, n + 2, 1000),
                     n := get(s, '~')),
                if s princ(s)),
                unknown) ]

// trace is refined in inspect.cl
// If trace_output() is known, use it, else use current output.
//
Trace <: Construct()
self_eval(self:Trace) : any
 -> (let a := self.args,
         l := list{ eval(x) | x in a},
         i := l[1],
         a2 := (if (length(a) > 1) a[2]) in
       (if (a2 % string & (case i (integer i <= system.verbose)))
           let p := get(ctrace, system) in
             (if known?(p) p := use_as_output(p),
              format(a2, l << 2),
              if known?(p) use_as_output(p),
              {})))

// assert is refined in trace.la
//
Assert <: Construct(Core/index:integer,external:string)

self_eval(self:Assert) : any
 -> (let a := self.args in
       (if (length(a) > 0 & known?(get(ctrace,system)) & not(eval(a[1])))
           let p := use_as_output(system.ctrace) in
             (printf("~S,line=~A: (ASSERT) ~S\n", self.external,
                     self.index, a[1]),
              use_as_output(p),
              if (system.Core/debug! >= 0) error("Assertion Violation"),
              {})))

self_eval(self:Branch) : any
 -> (if (length(self.args) != 1)
         error("[104] Syntax error with ~S (one arg. expected)",self),
     try (choice(), if (eval(self.args[1]) != false) true else (backtrack(), false))
     catch contradiction (backtrack(), false))

// end of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| define.cl                                                   |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------
// this file contains all definition & instanciation instructions
//---------------------------------------------------------------

// **************************************************************************
// * Contents:                                                              *
// *     Part 1: Definition instructions (Defobj, Defclass, Defmethod ...)  *
// *     Part 2: the instantiation macros                                   *
// *     Part 3: the useful stuff                                           *
// *     Part 4: the other macros                                           *
// **************************************************************************

extract_item :: property()
function! :: property()

iClaire/LastComment:any := unknown
claire/NeedComment:boolean := false

// *********************************************************************
// *     Part 1: Definition                                            *
// *********************************************************************
// this is the basic class instantiation
//
Defclaire <: Complex_instruction()
Definition <: Defclaire(arg:class,args:list)

self_print(self:Definition) : any
 -> printf("~S(~I)", self.arg, printbox(self.args))

// ------------- named object definition ------------------------------
//
Defobj <: Definition(ident:symbol)

self_print(self:Defobj) : void
 -> (if (arg(self) = global_variable)
       let r:any := any, v := unknown in
          (for x:Call in self.args
             (if (x.args[1] = value) v := x.args[2]
              else if (x.args[1] = range) r := x.args[2]),
           if r printf("~A:~S := ~I",self.ident,r,printexp(v,false))
           else printf("~A :: ~I",self.ident,printexp(v,false)))
     else printf("~A :: ~S(~I)", self.ident, (self.arg as any),
            printbox(self.args)))

// ------------- class definition ------------------------------------
//
Defclass <: Defobj(params:list, forward?:boolean)

self_print(self:Defclass) : void
 -> printf("~A~I <: ~S(~I)", self.ident,
           (if self.params printf("[~I]", princ(self.params))),
           self.arg,
           (let %l := pretty.index,
                l := self.args,
                n := length(l) in
              for i in (1 .. n)
                (if (i = 1) set_level()
                 else lbreak(),
                 case l[i]
                  (Vardef
                     ppvariable(l[i]),
                   any printf("~I = ~S", ppvariable(l[i].args[1]),
                              l[i].args[2])),
                 if (i < n) princ(","))))

// -------------- method definition ----------------------------------
//
Defmethod <: Defclaire(arg:Call,set_arg:any,body:any,inline?:any)

self_print(self:Defmethod) : void
 -> (printf("~S(~I) : ~I~I ~A ~I ", self.arg.selector,
            (if known?(args,self.arg) ppvariable(self.arg.args)), // v3.3.24
            printexp(self.set_arg,false),
            (lbreak(), pretty.index :+ 4),
            (if self.inline? "=>" else "->"),
            printexp(self.body, false)),
     pretty.index :- 4)

// -------------- array definition -----------------------------------
Defarray <: Defmethod()

self_print(self:Defarray) : void
 -> (printf("~S[~I] : ~S~I := ~I ", self.arg.args[1],
            ppvariable(cdr(self.arg.args)), self.set_arg,
            (lbreak(), pretty.index :+ 4), printexp(self.body, false)),
     pretty.index :- 4)

// -------------- rule definition ------------------------------------
Defrule <: Defclaire(ident:symbol,args:list,arg:any,body:any)

self_print(self:Defrule) : void
 -> (printf("~A(~I) :: rule(~I ~S ~I=> ~S)", self.ident, ppvariable(self.args),
            lbreak(4), self.arg, lbreak(4), self.body),
     pretty.index :- 4)

Defvar <: Defclaire(ident:Variable,arg:any)

self_print(self:Defvar) : void
 -> printf("~I := ~I", ppvariable(self.ident), printexp(self.arg, false))

// *********************************************************************
// *     Part 2: the general instantiation macro                       *
// *********************************************************************
// creation of a new object
//
self_eval(self:Definition) : any
 -> (let %c := self.arg,
         %o := (if (%c.open <= 0) error("[105] cannot instantiate ~S", %c),
                mClaire/new!(%c)) in                   // v3.2.26
       (if (%c.open != ephemeral()) write(instances, %c, %c.instances add %o),
        complete(%o, self.args)))

// the instantiation body is a sequence of words from which the initialization
// of the object must be built.
//
complete :: property()
complete(self:object,%l:list) : any
 -> (for x:Call in %l
       let p := make_a_property(x.args[1]),
           y := eval(x.args[2]),
           s := (p @ self.isa) in
         case s
          (slot (if not(y % s.range) range_is_wrong(s, y)
                else mClaire/update(p, self, s.index, s.Core/srange, y)),
           any error("[106] the object ~S does not understand ~S", self, p)),
     Kernel/complete!(self))

// creation of a new named object
//
self_eval(self:Defobj) : any
 -> (let %c := self.arg in
       (if (%c.open <= 0) error("[105] cannot instantiate ~S", %c),
        if (%c inherit? thing)
           let %o := mClaire/new!(%c, self.ident) in
             (case %o (property (if (length(%o.restrictions) > 0)     // v3.2.58 : cause compiler problems !
                                  error("[188] the property ~S is already defined", %o))),
              complete(%o, self.args))
        else let ob := mClaire/new!(%c) in
               (if (%c.open != ephemeral()) add!(instances, %c, ob),
                put(self.ident, complete(ob, self.args)))))

// creation of a new named object
self_eval(self:Defclass) : any
 -> (if (get(self.ident) % class &
                ( (get(self.ident) as class).open != -2 |    // new in v2.5
                  self.arg != (get(self.ident) as class).superclass))
        error("[107] class re-definition is not valid: ~S",self)
     else if (self.arg.open = 1 | self.arg.open = -1)      // v3.2.06  (moved)
           error("[109] the parent class ~S of ~S is closed", self.arg, self)
     else let %o := class!(self.ident, self.arg) in
       (for x in self.args
          let v := unknown in
            (case x (Call (v := eval(x.args[2]), x := x.args[1])),
             let rt := extract_type(x.range),
                 p := make_a_property(x.mClaire/pname), 
                 ps := last(slots(%o)) as slot, ix := ps.index in
               (if (known?(v) & not(v % rt))
                   error("[108] default(~S) = ~S does not belong to ~S",x,v,rt),
                if (p.open <= 0 &
                     exists(sx in self.arg.slots | sx.selector = p))
                   error("[181] cannot overide a slot for a closed property ~S",p),
                if (ps.range = float) ix :+ 1,
                add_slot(%o, p,rt, v, ix + 1))),             // v3.2 add ix
        close(%o),
        if self.forward? write(open,%o,-2) else if (%o.open = -2) write(open,%o,2),
        if (%o <= import)  %o.open := -1,                     // v3.2.40 avoid junk !
        put(params, %o, self.params),
        for p in self.params write(open, p as property, 0),
        attach_comment(%o),
        %o))

// method definition
LDEF:any :: list() // v0.01
self_eval(self:Defmethod) : any
 -> (if not(self.arg % Call)
        error("[110] wrong signature definition ~S", self.arg),
     let p := make_a_property(self.arg.selector),
         l := self.arg.args,
         lv := (if (length(l) = 1 & l[1] = system)
             list(Variable(mClaire/pname = symbol!("XfakeParameter"), range = void))
          else l),
         lp := extract_signature(lv),
         lrange := extract_range(self.set_arg, lv, LDEF),
         lbody := extract_status(self.body),
         m:method := add_method(p, lp, lrange[1], lbody[1], lbody[2]) in
       (if (p.open > 0 & p.open <= 1 & p.mClaire/dispatcher = 0)       // v3.2.22 : no warning for interface methods                                               // v3.2.04
         when r := some(r in (p.restrictions but m) | (r.domain ^ m.domain)) in
           // error("[186] conflict between ~S and ~S is not allowed for ~S", m,r,p),
           trace(1,"--- WARNING ! [186] conflict between ~S and ~S is dangerous since ~S is closed\n", m,r,p), // v3.2.06
        LDEF := list<any>(),
        if (lbody[3] != body) put(formula, m, lambda!(lv, lbody[3])),
        if (length(lrange) > 1) put(typing, m, lrange[2]),
        write(inline?, m, self.inline?),
        attach_comment(m),
        if (p = close & not(m.range <= domain!(m)))                     // v3.2.01
          error("[184] the close method ~S has a wrong range",m),
        m))

// v3.2.24
(%.open := -1,
 >=.open := -1,
 =.open := -1)

// attach a cute comment if needed ... to a defclass or a defmethod
attach_comment(x:any) : void
  -> (if (NeedComment & known?(LastComment))  x.comment := LastComment)


// returns the list of types AND modifies LDEF
[extract_signature(l:list) : list
 -> LDEF := list<any>(),
    let n := 0 in
       list{ (if not(v % Variable) error("[111] wrong typed argument ~S",v)  // v3.2.14
              else let p := extract_pattern(v.range, list(n)) in
                (n :+ 1,
                 if (p = unknown) error("[111] wrong typed argument ~S (~S)", v, v.range),
                 put(range, v, (type!@any(p))),
                 p)) |
         v:Variable in l} ]

// takes an <exp> that must belong to <type> and returns the CLAIRE type
// if LDEF is non-empty, it is used as a list of type variable and patterns
// may be returned. In addition, if the path list is non empty, new type
// variables may be defined. a syntax error will produce the unknown value
//
extract_pattern(x:any,path:list) : any
 -> (case x
      (class x,
       set let z := (if (length(x) = 1) extract_pattern(x[1], nil)) in
             case z
              (Reference let w:Reference := copy(z) in
                           (write(arg, w, true), w),
               any x),
       Tuple  let ltp := list{extract_pattern(z,path) | z in x.args} in
                    (if exists(y in ltp | unknown?(y)) unknown
                     else tuple!(ltp)),  // v3.0.56
       global_variable extract_pattern(x.value, path),
       Call let p := x.selector in
              (if (p = U)
                  let x1 := extract_pattern(x.args[1], nil),
                      x2 := extract_pattern(x.args[2], nil) in
                    (if (x1 = unknown | x2 = unknown) unknown else x1 U x2)  // v3.2.48
               else if (p = ^)
                  extract_pattern(x.args[1], nil) ^
                    extract_pattern(x.args[2], nil)
               else if (p = ..)
                  let v1 := extract_item(x.args[1], nil),
                      v2 := extract_item(x.args[2], nil) in
                    (if (v1 % integer & v2 % integer) (v1 .. v2) else unknown) //<yc> v3.0.02
               else if (p = nth) extract_pattern_nth(x.args, path)
               else if (p = *) when z := extract_pattern(x.args[1], path) in
                                 (z U {unknown})      // v3.1.14
                               else unknown
               else unknown),
       type x,
       unbound_symbol let s := extract_symbol(x),
                   v := some(z in LDEF | z.mClaire/pname = s) in
                 (if known?(v) v.range
                  else if (case path (list length(path) > 1))
                    let y := Reference(index = path[1],  args = cdr(path)),
                        v := Variable(mClaire/pname = s, range = y) in
                      (LDEF :add v, void)
                  else unknown),
       any unknown))

// takes an <exp> that must belong to <type> and returns the CLAIRE type
//
extract_type(x:any) : type
 -> (LDEF := list<any>(),
     let r := extract_pattern(x, nil) in
       (if (r = unknown) error("[112] wrong type expression ~S", x)
        else r as type))

// an item is an integer, a float, a symbol, a string or a type
//
extract_item(x:any,y:any) : any
 -> (if (x % ((((integer U float) U symbol) U string) U type)) x
     else if (x % global_variable) extract_item(x.value, y)
     else unknown)

// version for X[...] which is the most complex case - note the extensibility
// patch.
[extract_pattern_nth(l:list,path:list) : any
 -> let m := length(l), x := l[1] in
      (if (m = 1) let y := extract_pattern(l[1], nil) in
                   (if unknown?(y) unknown
                    else Param(arg = array, params = list(of),args = list(set(y))))
       else if (m = 2)
           (if (x % {list, set, subtype} | not(x % class))
               let y := extract_pattern(l[2], nil) in
                 try (if known?(y) l[1][y] else unknown) catch any unknown
            else unknown)
       else let l1 := l[2],               // list of properties pi
                l2 := l[3].args,          // list of expressions ei in C[pi:ei]
                l3 := list<any>() in
              (for n in (1 .. length(l1))
                  let y := l2[n] in
                    l3 :add
                      (case y
                        (Set
                           let v := extract_pattern(y.args[1],
                                                    copy(path) add l1[n]) in
                             case v
                              ({void} any,
                               Reference  let z := copy(v) in  (put(arg, z, true), z),
                               any set((if known?(v) v else eval(y.args[1])))),
                         any
                           extract_pattern(y, (if (length(path) != 0) path add l1[n])))),
                if (unknown % l3) unknown
                else Param(arg = x, params = l1, args = l3))) ]

// we perform some pre-processing on x[l] at reading time to make evaluation easier
[extract_class_call(self:class,l:list) : object
 ->  if (self % {list, set, subtype} & length(l) = 1 &   // v3.0.01
         (let y := l[1], z :=  extract_pattern(y,nil) in     // recognize the form list[t] and list<t> :: list[of = t]
            (case y (global_variable  y := l[1].value),
             (z % type | self = subtype |                // v3.0.48
             (case y (Call (y.selector != = | length(y.args) != 2),
                      Tuple true))))))
        Call(nth, self cons l) // ??  v3.2 ! list[t] -> subtype
     else if (self = lambda)
        (if (length(l) = 2 & (l[1] % Do | l[1] % Variable))
            let lv := (if (l[1] % Do) list{ v in l[1].args | v % Variable}
             else list(l[1])) in
              (extract_signature(lv), lambda!(lv, l[2]))
         else error("[113] Wrong lambda definition lambda[~S]", l))
     else let l1 := list<any>(),
              l2 := list<any>(),
              m := length(l) in
            (for n in (1 .. m)
               let y := l[n],
                   p := unknown,
                   v := unknown in
                 (case y
                   (Call (if not((y.selector = = & length(y.args) = 2))
                             error("[114] Wrong parametrization ~S", y),
                          p := make_a_property(y.args[1]),
                          v := Set(args = list(y.args[2]))),
                    Vardef
                      (p := make_a_property(y.mClaire/pname), v := y.range),
                    any (p := make_a_property(y), v := {})),
                  l1 :add p,
                  l2 :add v),
             Call( nth, (self cons list(l1, List(args = l2))))) ]

// extract the range (type and/or second-order function)
// lvar is the list of arguments that will serve as second-o. args
// ldef is the list of extra type variables that are defined in the sig.
[extract_range(x:any,lvar:list,ldef:list) : list
 -> if not((case x (Call (x.selector = nth & x.args[1] = type))))
        list(extract_type(x), {})
     else (for v in ldef
             let r := v.range as Reference,
                 path := r.args,
                 n := length(path),
                 y := lvar[r.index + 1] in
               (for i in (1 .. length(path)) y := Call(@, list(y, path[i])),
                x := substitution(x, v, Call(member, list(y)))),
           let lv2 := list<any>() in
             (for v in lvar
                let v2 := Variable(mClaire/pname = v.mClaire/pname, range = type) in
                  (lv2 :add v2, x := substitution(x, v, v2)),
              let lb := lambda!(lv2, x.args[2]),
                  ur := unknown in
                (try ur := apply(lb, list{ v.range | v in lvar})
                 catch any (printf("The type expression ~S is not valid ... \n", x),
                            printf("context: lambda = ~S, lvars = ~S\n",lb,list{v.range | v in lvar}),
                            close(system.exception!)),
               if not(ur % type)
                  error("[115] the (resulting) range ~S is not a type", ur),
               list(ur, lb)))) ]

// define the different components of status(m), which is a bit vector
claire/NEW_ALLOC :: 1          // a new allocation may be done by running the method
claire/BAG_UPDATE :: 2         // a list is updated whose content is not gcsafe
claire/SLOT_UPDATE :: 3        // an slot is updated whose content is not gcsafe
claire/RETURN_ARG :: 4         // the method returns one of its args
claire/SAFE_RESULT :: 5        // the result (not gcsafe) does not need protection
claire/SAFE_GC :: 6            // the args (not gcsafe) does not need protection
claire/STRING_UPDATE :: 7      // a string is modified hence constant strings are forbiden  v3.3.46

// create a bitvector from a list of flags
claire/bit_vector :: property()
claire/bit_vector(l:listargs) : integer
   -> let d := 0 in (for x in l d :+ ^2(x), d)

// parse the body and return (status, functional, body)
// the input is  body | (function!(f) | function!(f,s)) < | body> opt
//
extract_status(x:any) : list
 -> (let s := unknown,
         f := (if (case x (Call x.selector = function!)) x else unknown) in
       (case x
         (And let y := x.args[1] in
                (if (case y (Call y.selector = function!))
                    (f := y, x := x.args[2])),
          Call (if (x.selector = function!) x := body),
          any nil),
        if known?(f)
           (x := body,
            if (length(f.args) > 1)
              s := integer!({(case u (integer u, global_variable value(u),
                                      any error("[116] ~S not allowed in function!",u))) |
                             u in cdr(f.args)})
            else s := 0,
            f := make_function(string!(extract_symbol(f.args[1])))),
        list(s, f, x)))

// cleans a pattern into a type
//
type!(x:any) : type
 -> (case x
      (list list{ type!(y) | y in x},
       Param Param(arg = x.arg, params = x.params,
                   args = list{ type!(y) | y in x.args}),
       Reference any,
       any x as type))

// creates a table
// to do in later versions: use an array if direct indexed access
// in the meanwhile, arrays of float should be used with care (indexed arrays)
//
self_eval(self:Defarray) : any
 -> (let a := (self.arg as Call).args,
         ar:table := mClaire/new!(table, extract_symbol(a[1])),
         v := (a[2] as Variable),
         s := extract_type(v.range),
         e := (let l := cdr(a),
                   b := lexical_build(self.body, l, 0) in
                 (if exists(va in l | occurrence(b, va) > 0) lambda!(l, b)
                  else self.body)),
         d := (case e (lambda unknown, any eval(self.body))) in
       (write(range, ar, extract_pattern(self.set_arg, nil)),
        if unknown?(range,ar) range_error(cause = table, arg = self.set_arg, wrong = type), // v3.3.18
        if (known?(d) & not(d % ar.range))                   // v3.1.06
           range_error(cause = ar,arg = d, wrong = ar.range),
        put(range, v, s),
        attach_comment(ar),
        if (class!(ar.range) inherit? set) write(multivalued?, ar, true)
        else if (class!(ar.range) inherit? list & not(ar.range % Tuple))
           write(multivalued?, ar, list),
        if (length(a) = 2)
           (write(domain, ar, s),
            case s
             (Interval (write(params, ar, s.Core/arg1 - 1),      // v3.1.06 -> make_copy_list
                        write(Core/graph, ar, make_copy_list(size(s), d))),
              any (write(params, ar, any),
                   write(Core/graph, ar, make_list(29, unknown)))),
            case e
             (lambda for y in ar.domain ar[y] := funcall(e, y),
              any write(default, ar, d)))
        else let s2 := extract_type((a[3] as Variable).range) in
               (write(domain, ar, tuple!(list(s, s2))),
                put(range, (a[3] as Variable), s2),
                if (s % Interval & s2 % Interval)
                   (write(params, ar,
                          list(size(s2),
                               ((s.Core/arg1 * size(s2)) +
                                   s2.Core/arg1) -
                                 1)),
                    write(Core/graph, ar, make_copy_list(size(s) * size(s2), d)))
                else (write(params, ar, any),
                      write(Core/graph, ar, make_list(29, unknown))),
                case e
                 (lambda for y1 in s
                          for y2 in s2 ar[y1,y2] := funcall(e, y1, y2),
                  any write(default, ar, d))),
        ar))

// ------------------ NEW in v3.2 : definition of rules -----------------------
//

// a demon is a lambda with a name and a priority
demon <: lambda(pname:symbol = symbol!("unamed"),
                priority:integer = 0,              // used by ClaireRules
                formula:lambda)

self_print(self:demon) : void -> princ(self.pname)
funcall(self:demon,x:any,y:any) : any -> funcall(self.formula,x,y)
funcall(self:demon,x:any,y:any,z:any) : any -> funcall(self.formula,x,y,z)

// in the interpreted mode we store the list of demons using a table
claire/demons[r:relation] : list<demon> := list<demon>()  // list of relevant demons

claire/<- :: operation()
rule_object <: property()

// the last rule/axiom that was defined on each relation
// this is used to find when the relation may be compiled
relations[r:rule_object] : set := {}               // list of involved relations
last_rule[r:relation] : rule_object := unknown     // compile(ru) => may compile(r)
(write(inverse, relations, last_rule))

// evaluate a rule definition: create a new demon and, if needed, the if_write 
// function
eval_rule :: property(open = 3)
self_eval(self:Defrule) : any 
 -> (if (self.args[1] != system) eval_rule(self)   // hook for ClaireRules engine
     else let %condition := self.arg,
              ru := get(self.iClaire/ident) in        // name of the rule
       (put(isa, ru, rule_object), 
        rule_object.instances :add ru,
        let (R,lvar) := make_filter(%condition) in
         let d := make_demon(R,ru.name,
                            lvar,%condition,lexical_build(self.body,lvar,0)) in
         (if (R.if_write % function)
             error("cannot define a new rule on ~S which is closed", R),
          demons[R] :add d,
          last_rule[R] := ru,
          if (length(demons[R]) = 1) eval_if_write(R),
          if (case R (property (length(R.restrictions) = 0)))
             eventMethod(R as property),
          ru)))

// an eventMethod is a property whose unique (?) restriction is a method
[eventMethod?(r:relation) : boolean
  -> case r (property forall(x in r.restrictions | not(x % slot))) ]
  
  
// check that condition is either a filter or the conjunction of a filter and a 
// condition
// a filter is R(x) := y | R(x) := (y <- z) | R(x) :add y | P(x,y)
// R(x) is x.r or A[x]
// the list of variable is of length 3 if R is mono-valued
[make_filter(cond:any) : tuple(relation,list[Variable])
  -> let c := (case cond (And cond.args[1], any cond)) in
       (//[5] make_filter : ~S (~S) // c, c.isa,
        if (case c (Call ((c.selector = write | c.selector = nth=) &
                          c.args[1] % relation)))
           let R := (c.args[1] as relation), 
               x := Variable(extract_symbol(c.args[2]),R.domain),
               y1 := c.args[3] in
             (if multi?(R) 
                 error("[188] wrong event filter ~S for multi-valued relation",c,R),
              if (case y1 (Call (y1.selector = <-)))
                 tuple(R,list(x,Variable(extract_symbol(y1.args[1]),R.range),
                              Variable(extract_symbol(y1.args[2]),R.range)))
              else tuple(R,list(x,Variable(extract_symbol(y1),safeRange(R)),
                                  Variable(gensym(),safeRange(R)))))
        else if (case c (Call ((c.selector = add) & c.args[1] % relation)))
           let R := (c.args[1] as relation), 
               x := Variable(extract_symbol(c.args[2]),R.domain),
               y := Variable(extract_symbol(c.args[3]),R.range) in
             tuple(R,list(x,y))
        else if (case c (Call (length(c.args) = 2)))
           let R := (c as Call).selector, 
               x := Variable(extract_symbol(c.args[1]),R.domain),
               y := Variable(extract_symbol(c.args[2]),R.range) in
             tuple(R,list(x,y)) 
        else error("[188] wrong event filter: ~S",c)) ]
       
  
// create a demon
// notice that a demon has 3 args if R is monovalued 
[make_demon(R:relation,n:symbol,lvar:list[Variable],cond:any,conc:any) : demon
   -> let x := lvar[1], y := lvar[2],
          %test:any := Call((if multi?(R) % else =), list(y, readCall(R,x))),
          %body:any := conc in
        (if (mClaire/trace!(if_write) > verbose())   // add a trace to the conclusion
           conc := Do(list(Call(format,list("--- trigger ~A(~S,~S)\n", 
                                             List(args = list(string!(n), x, y)))), 
                           conc)),
         %body := If(arg = conc),
         if eventMethod?(R)
            case cond (And %test := (if (length(cond.args) > 2)
                                        And(args = cdr(cond.args))
                                     else cond.args[2]),
                       any %body := conc)
         else case cond (And %test := And(args = list(%test) /+ cdr(cond.args))),        
         case %body (If %body.test := %test),
         demon(pname = n,
               formula = lambda!(lvar,%body))) ]

// cute litle guy
[readCall(R:relation,x:any) : Call
  -> if (R % table) Call(get, list(R, x))                // v3.3.0
     else Call+(selector = R, args = list(x)) ]             

// a small brother
[putCall(R:relation,x:any,y:any) : Call
  -> if multi?(R) Call(add_value,list(R,x,y))
     else Call(put,list(R,x,y)) ]

// v3.3 : find the range when we read the current value     
[safeRange(x:relation) : type
  -> case x (property  (if forall(s in x.restrictions | (case s (slot s.default % s.range)))
                           x.range
                        else any),
             table  (if (x.default % x.range) x.range else any),
             any any) ]
          
// generate an if_write "daemon", only the first time, which uses
// the list in demons[R]
// the first step is to make the update (with inverse management)
eval_if_write(R:relation) : void
 -> let l := demons[R],
        lvar := l[1].formula.vars,  // list(x,y,?z) from 1st demon
        dv := Variable(gensym(),demon),
        l1 := list<any>(putCall(R,lvar[1],lvar[2])),
        l2 := list<any>(For(var = dv,
                            iClaire/set_arg = Call(nth,list(demons,R)),
                            arg = Call(funcall,list(dv) /+ lvar))) in
     (for v in lvar put(range,v,class!(v.range)),
      if known?(inverse,R)
         (if not(multi?(R)) 
            l1 :add Call(Core/update-,list(R.inverse,lvar[3],lvar[1])),
          l1 :add putCall(R.inverse,lvar[2],lvar[1])),
      R.if_write := lambda!( list(lvar[1],lvar[2]),
         (if eventMethod?(R) Do(l2)
          else if multi?(R)
             If(test = Call(not,
                            list(Call(%,list(lvar[2],readCall(R,lvar[1]))))),
                arg = Do(l1 /+ l2))
          else Let(var = lvar[3],
                   value = readCall(R,lvar[1]),
                   arg = If(test = Call(!=,list(lvar[2],lvar[3])),
                            arg = Do(l1 /+ l2))))))
              
// create a restriction (method) that will trigger an event
eventMethod(p:property) : void
 -> let m:method := add_method(p, list(p.domain, p.range),void,0,unknown) in
       (put(formula, m, p.if_write),
        put(functional, m, make_function(string!(p.name) /+ "_write")))

// new in v3.1: the inter face pragma ******************************

// this array is used to store the declarations
InterfaceList[c:class] : list := nil

claire/interface :: property()

// define a property as an interface
[claire/interface(p:property) : void
 -> if not(p.restrictions)
       error("[185] cannot define an empty property ~S as an interface",p),
    if (not(Core/uniform(p)) | float % domain(p.restrictions[1]))
       error("[185] cannot define an non-uniform property ~S as an interface",p),
    let d := domain!(p.restrictions[1]),
        ls := list<any>() in
      (for p2 in property
        (if (p2.mClaire/dispatcher > 0 & p2.domain glb p.domain)
            ls :add p2.mClaire/dispatcher),
       for x in p.restrictions d :meet domain!(x),
       p.domain := d,
       p.mClaire/dispatcher := some(i in (1 .. (length(ls) + 1)) |
                                    not(i % ls))) ]

claire/interface(c:class,l:listargs) : void
  -> (InterfaceList[c] := list<property>{x in l | x % property},
      let px := claire/interface in            // v3.2 trick to avoid ignore !
         for p in InterfaceList[c] 
           (if (p.open = 3) call(px,p)))       // only implied for open properties !!!!


// ****************** Construction *********************************
// filling the evaluation form
(table.open := 0,
 class.open := 0,
 for x in Instruction.descendents
  let m := (self_eval @ x) in
    (x.open := 3,
     case m (method put(mClaire/evaluate, x, m.functional))))

//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| file.cl                                                     |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------------
// this file contains all that is related to files + top-level
// --------------------------------------------------------------------

// **********************************************************************
// * Contents:                                                          *
// *  Part 1: Utilities                                                 *
// *  Part 2: Loading                                                   *
// *  Part 3: Reading in a file/string & top-level                      *
// *  Part 4: The show & kill methods + macro-methods                   *
// **********************************************************************


// **********************************************************************
// *   Part 1: Utilities                                                *
// **********************************************************************


// useful gadgets
//
[self_eval(self:delimiter) : any
 -> next(reader),                       // v3.1.04 better safe than sorry
    error("[117] loose delimiter ~S in program [line ~A ?]", self, reader.nb_line)]

(put(mClaire/evaluate, delimiter, (self_eval @ delimiter).functional))

// a small useful function
// PORTABILITY WARNING: the following assumes newline is ^J (ASCII 10 dec)
// PORTABILITY WARNING: what about ^M (ASCII 13 dec)
//
// a small usefull function
[useless_c(r:integer) : boolean
 -> if (r = 10 | r = 13) write(nb_line, reader, reader.nb_line + 1),
    (r = reader.space | r = 10 | r = 13 | r = 32 | r = reader.tab) ]

// take care of PC format (10 + 13)
skipc(self:meta_reader) : any
 -> (while useless_c(firstc(self))
           let b := (firstc(self) = 10) in
             (next(self), if (b & firstc(self) = 13) next(self)),
     firstc(self))

// look for a meaningful termination char such as ) or ]
skipc!(r:meta_reader) : any
 -> (let c := skipc(r) in
       (if (c = 59)
           (while (r.firstc != r.eof & r.firstc != 10) next(r),
            if (r.firstc = r.eof) EOF
            else (write(nb_line, r, r.nb_line + 1), skipc!(r)))
        else if (c = 47)
           let x := Kernel/read_ident(r.fromp) in
              (if (x % string) skipc!(r) else 47)
        else c))

cnext(self:meta_reader) : meta_reader -> (next(self), self)
findeol(self:meta_reader) : boolean
 -> ((while useless_c(firstc(self))
        (if (firstc(self) = 10) break(true), next(self))) |
     firstc(self) = self.eof)

// safety checking
//
checkno(r:meta_reader,n:integer,y:any) : any
 -> (if (r.firstc != n) r
     else Serror("[118] read wrong char ~S after ~S", list(char!(n), y)))

// reads a keyword inside a control structure
//
verify(t:any,x:any,y:any) : any
 -> (if (x % t) x
     else Serror("[119] read ~S instead of a ~S in a ~S", list(x, t, y)))

// prints a syntax error
//
Serror(s:string,la:list) : {}
  -> (printf("---- Syntax Error[line: ~A]:\n", reader.nb_line),
      flush(reader.fromp),
      general_error(cause = s, arg = la))

; -> (printf("Syntax error: ~I\n", format(s, la)),
;     flush(reader.fromp),
;     error("Error occurred in line ~A", reader.nb_line))

// the reader-------------------------------------------------------------
//
reader :: meta_reader(space = 202,
                      eof = externC("((int) EOF)",integer),          // should be -1
                      tab = 9, index = 1,
                      external = "toplevel",
                      bracket = mClaire/new!(delimiter, symbol!("]")),
                      paren = mClaire/new!(delimiter, symbol!(")")),
                      comma = mClaire/new!(delimiter, symbol!(",")),
                      curly = mClaire/new!(delimiter, symbol!("}")))

// variable handling -------------------------------------------------
// reads a variable
//
extract_variable(self:any) : Variable
 -> (if (case self (Variable get(self.mClaire/pname) != self))
        (put(range, self as Variable, extract_type(self.range)),
         self as Variable)
     else let v := Variable(mClaire/pname = extract_symbol(self)) in
            (reader.last_form := v, v))

// create a variable and add it to the lexical environment
bind!(self:meta_reader,%v:Variable) : list
 -> (put(index, %v, self.index),
     let value := get(%v.mClaire/pname) in
       (put(index, self, self.index + 1),
        if (self.index > self.maxstack) put(maxstack, self, self.index),
        put(%v.mClaire/pname, %v),
        list(%v, value)))

// remove a variable from the lexical environment
//
unbind!(self:meta_reader,%first:list) : any
 -> (let var := %first[1] in
       (put(index, self, self.index - 1),
        put(var.mClaire/pname, %first[2])))

// declaration of the CLAIRE standard ports ----------------------------
// the internal standard ports are transmitted via two strings in the
// symbol table.
//
stdout :: global_variable(range = port,
                          value = get(symbol!("STDOUT", claire)))
(write(ctrace, system, stdout))

stdin :: global_variable(range = port,
                         value = get(symbol!("STDIN", claire)))

*fs*:string :: Id(*fs*)

/(s:string,s2:string) : string -> ((s /+ *fs*) /+ s2)

// basic methods defined in creader.c -----------------------------------
// TODO move!
// flush(self:port) : any -> function!(flush_port)

// this function is called by the main and restores the reader in a good shape. Also
// closes the input port to free the associated file ! <yc>
[Core/restore_state(self:meta_reader) : void
 ->  if (self.fromp != stdin) fclose(self.fromp),
     put(fromp, self, stdin),
     put(index, self, 1),
     flush(stdin,32),                            // v3.3.10  
     Core/restore_state() ]

// *********************************************************************
// *   Part 2: Loading                                                 *
// *********************************************************************

// sload is the interactive version.
//
load_file(self:string,b:boolean) : any
 -> (write(index, reader, 0),
     write(maxstack, reader, 0),
     reader.nb_line := 1,
     reader.external := self,
     trace(2, "---- [load CLAIRE file: ~A]\n", self),
//     try
     let s2 := (self /+ ".cl"),
         p1:port := (try fopen(s2, "r")
                     catch any try fopen(self, "r")
                     catch any error("[120] the file ~A cannot be opened", self)),
         start := mClaire/base!(),  top := mClaire/index!(),
         p2 := reader.fromp,
         b2 := reader.toplevel,     // v3.1.16 !! remove c2 = ....
         *item* := unknown in
       (mClaire/set_base(top),
        reader.fromp := p1,
       // reader.firstc := 32,
        reader.toplevel := false,
        *item* := readblock(p1),
        while not(*item* = eof)
          (if b printf("~A:~S\n",reader.nb_line,*item*),
           mClaire/set_index(top + (reader.maxstack + 1)),
           case *item* 
             (string (if NeedComment      // v3.1.16 -> improve comment
                       (if known?(Language/LastComment)
                           Language/LastComment :/+ ("\n-- " /+ *item*)  
                        else Language/LastComment :=
                                     ("[" /+ reader.external /+ "(" /+ string!(reader.nb_line)
                                       /+ ")]\n-- " /+ *item*))),
              any (*item* := eval(*item*), 
                   Language/LastComment := unknown)),
           if b printf("=> ~S \n\n", *item*),
           *item* := readblock(p1)),
        mClaire/set_base(start),
        mClaire/set_index(top),
        reader.toplevel := b2,
        reader.fromp := p2,
        reader.external := "toplevel",
        fclose(p1)),
//     catch general_error
//       (printf("---- file ~S, line ~S\n",self,reader.nb_line),
//        close(system.exception!)),
     true)

// the simple load
//
load(self:string) : any -> load_file(self, false)
sload(self:string) : any -> load_file(self, true)

// loading a module into the system.
// The correct package is open and each file is loaded.
[load_file(self:module,b:boolean) : void
 ->  if (self.mClaire/status = 2)
        (funcall(self.mClaire/evaluate, any, any, any),
         self.mClaire/status := 3)
     else if (self.mClaire/status = 0 & known?(source,self))
        (trace(3, "---- Loading the module ~S.\n", self),
         begin(self),
         let s := (self.source /+ *fs*) in
           for x in self.made_of load_file((s /+ x) /+ ".cl", b),
         self.mClaire/status := 1),
     end(self) ]

// the simple load
//
load(self:module) : any
 -> (for x in add_modules(list(self)) load_file(x, false))
sload(self:module) : any
 -> (for x in add_modules(list(self)) load_file(x, true))

// This is a very important method which adds the right order the
// modules that must be loaded to load oself. the list l represents the
// list of modules that we know will be in the result. result represent
// the current list of ordered modules
//
add_modules(self:module,l:set,result:list) : list
 -> (if (self % result) result
     else if (self % l) result add self
     else (l := l add self,
           for x in self.uses
             case x (module result := add_modules(x, l, result)),
           if not(self % result) result := result add self,
           for x in self.parts result := add_modules(x, l, result),
           result))

// this methods takes a list of modules that must be loaded and returns
// a list of modules that are necessary for the definition
//
add_modules(self:list) : list
 -> (let l := list<module>() in
       (for x in self l := add_modules(x, set!(l), l), l))

// load a file of expressions (quite useful)
eload(self:string) : any
 -> (reader.index := 0,
     reader.maxstack := 0,
     reader.nb_line := 1,
     reader.external := self,
     trace(2, "---- [eload CLAIRE file: ~A]\n", self),
     let s2 := (self /+ ".cl"),
         p0:port := reader.fromp, // c0 := reader.firstc,
         p1:port := (try fopen(s2, "r")
                     catch any try fopen(self, "r")
                     catch any error("[120] the file ~A cannot be opened", self)),
         start := mClaire/base!(),
         top := mClaire/index!(),
         b2 := reader.toplevel,
         *item* := unknown in
       (mClaire/set_base(top),
        reader.toplevel := false,
        reader.fromp := p1,
        *item* := read(p1),
        while not(*item* = eof)
          (mClaire/set_index(top + (reader.maxstack + 1)),
           *item* := eval(*item*),
           *item* := read(p1)),
        mClaire/set_base(start),
        mClaire/set_index(top),
        reader.fromp := p0,
    //    reader.firstc := c0,                                 v3.2.36 !
        reader.toplevel := b2,
        reader.external := "toplevel",
        fclose(p1)),
   true)


// *********************************************************************
// *   Part 3: Read & Top-level                                        *
// *********************************************************************

// The standard read function.
// This method reads from a CLAIRE port (self).
// We first check if self is the current reading port.
// the last character read (and not used) is in last(reader)
[readblock(p:port) : any
 ->  if (reader.fromp = p) nextunit(reader)
     else let // v := reader.firstc,
              p2 := reader.fromp in
            (put(fromp, reader, p),
             let val := nextunit(reader) in
               (put(fromp, reader, p2),
                if (val = paren(reader) | val = curly(reader) | val = comma(reader) | val = bracket(reader))
                   Serror("[117] Loose ~S in file", list(val)),
                val)) ]

// read reads a closed expression
[read(p:port) : any
 -> let p2 := reader.fromp in
    //    v := reader.firstc in
       (if (p != p2) (put(fromp, reader, p)), // , put(firstc, reader, 32)),
        let val := (if (skipc(reader) = reader.eof) eof
         else nexte(reader)) in
          (if (p != p2) put(fromp, reader, p2),
           if  (val = paren(reader) | val = curly(reader) | val = comma(reader) | val = bracket(reader))
               Serror("[117] Loose ~S in file", list(val)),
           val)) ]

// read into a string
[read(self:string) : any
 ->  let b := reader.toplevel,
         p := reader.fromp,
         x := unknown in
      (reader.toplevel := true,
       reader.fromp := port!(self),
       try (x := nextunit(reader),
            reader.fromp := p)
       catch any (reader.fromp := p,
                   close@exception(system.exception!)),
       reader.toplevel := b,
       x) ]

q :: keyword()
call_debug :: property()

// used by the top level
EVAL[i:(0 .. 99)] : any := unknown

// calls the debugger
debug_if_possible() : any
 -> (if (system.Kernel/debug! >= 0)
        funcall((call_debug.restrictions[1] as method).functional, any,
              system, any)
     else print_exception())

// a method for calling the printer without issuing a message (that would
// modify the stack and make debugging impossible).
// here we assume that self_print is always defined and is always a compiled
// function
print_exception() : any
 -> (let p := use_as_output(stdout),
         %err := system.exception!,
         %prop := ((self_print @ owner(%err)) as method) in
       (try (if known?(functional, %prop)
            funcall(%prop.functional, object, %err, any)
         else funcall(%prop, %err))
        catch any printf("****** ERROR[121]: unprintable error has occurred.\n"),
      use_as_output(p)))

// **********************************************************************
// *  Part 4: The show & kill methods + macro-methods                   *
// **********************************************************************

pretty_show :: property(open = 3)

//----------------- printing an object -------------------------
// %show is an open restriction which allow to show the value of a
// binary relation
//
// this method is the basic method called for show(..)
//
show(self:any) : any
 -> (case self
      (object for rel in owner(self).slots
               printf("~S: ~S\n", rel.selector, get(rel, self)),
       any printf("~S is a ~S\n", self, owner(self))),
     true)

// This is the good version of kill, the nasty one is dangerous ....
// these restrictions of kill explain the dependencies among objects
//
claire/kill(self:object) : any
 -> (case self (thing put(self.name, unknown)),
     write(instances, self.isa, self.isa.instances delete self),
     {})

claire/kill(self:class) : any
 -> (while self.instances kill(self.instances[1]),
     for x in self.descendents (if (x.superclass = self) kill(x)),
     kill@object(self))

// our two very special inline methods
min(x:integer,y:integer) : integer => (if (x <= y) x else y)
max(x:integer,y:integer) : integer => (if (x <= y) y else x)

min(x:float,y:float) : float => (if (x <= y) x else y)
max(x:float,y:float) : float => (if (x <= y) y else x)

min(x:any,y:any) : type[x U y] => (if (x <= y) x else y)
max(x:any,y:any) : type[x U y] => (if (x <= y) y else x)

// this is a useful macro for hashing
[mClaire/hashgrow(l:list,hi:property) : list
 =>  let l1 := l,
         l2 := make_list(nth_get(l1, 0) * 2, unknown) in
       (for x in l1 (if known?(x) hi(l2, x)), l2) ]

// check if the value if known?
known?(a:table,x:any) : boolean => (get(a,x) != unknown)
unknown?(a:table,x:any) : boolean => (get(a,x) = unknown)

float!(self:string) : float
 -> let x := read(self) in
      (case x (float x,
               integer float!(x),                     // v3.3.22
               any error("[??] ~A is not a float",self)))

// v3.00.46 a new macro
>=(self:any,x:any) : boolean => (x <= self)

// v3.3: a recursive macro
;claire/quick_sort(self:list,f:property,n:integer,m:integer) : void
; => (if (m > n)
;        let x := self[n] in
;          (if (m = (n + 1))
;              (if call(f, self[m], x)
;                  (self[n] := self[m], self[m] := x))
;           else let p := (m + n) >> 1, q := n in   // new: p is pivot's position
;                  (x := self[p],
;                   if (p != n) self[p] := self[n],
;                   for p in ((n + 1) .. m)
;                     (if call(f, self[p], x)
;                         (self[n] := self[p],
;                          n := n + 1,
;                          if (p > n) self[p] := self[n])),
;                   self[n] := x,
;                   quick_sort(self, f, q, n - 1),
;                   quick_sort(self, f, n + 1, m))))

// v3.3.42 add macros to use float & integers easily
[+(x:integer,y:float) : float => float!(x) + y]
[*(x:integer,y:float) : float => float!(x) * y]
[/(x:integer,y:float) : float => float!(x) / y]
[-(x:integer,y:float) : float => float!(x) - y]
[+(x:float,y:integer) : float => x + float!(y)]
[*(x:float,y:integer) : float => x * float!(y)]
[/(x:float,y:integer) : float => x / float!(y)]
[-(x:float,y:integer) : float => x - float!(y)]

// v3.4 a useful macro
claire/sqr(x:integer) : integer => (x * x)
claire/sqr(x:float) : float => (x * x)

//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| function.cl                                                 |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------------
// This file hold the methods that are defined by an external function
// and those that apply to a primitive type
// --------------------------------------------------------------------

// *********************************************************************
// *  Table of contents                                                *
// *   Part 1: Basics of pretty printing                               *
// *   Part 2: Methods for CLAIRE objects                              *
// *   Part 3: System Methods                                          *
// *   Part 4: Methods for Native entities                             *
// *********************************************************************


// we find here what is necessary for the minimal kernel of CLAIRE
// ==============================================================
!= :: operation(precedence = 60)
<< :: operation()
>> :: operation()
and :: operation()
or :: operation()
U :: operation(precedence = 50)
less? :: operation(precedence = 60, range = boolean)
& :: operation()
min :: operation(precedence = 20)
max :: operation(precedence = 20)
meet :: operation()
inherit? :: operation()


// *********************************************************************
// *   Part 1: Basics of pretty printing                               *
// *********************************************************************

cpstack :: property()

// we use a nice object
pretty_printer <: thing(cpretty:port,       	// a string port
                        cprevious:integer = 0,  // index of the current port in the stack 
                        index:integer = 0,      // indentation level
                        width:integer = 75,	    // size of window
                        pprint:boolean = false, // active
		                pbreak:boolean = false,
                        cpstack:list)           // support reccursive print-in-string 

pretty :: pretty_printer(cpretty = port!(), cpstack = nil)

apply_self_print :: property()
short_enough :: property()
print :: property()

// buffered print
// new in v3.3.26: unbounded recursion is supported :-)
[print_in_string() : void
 -> let n := pretty.cprevious + 1,
        p1 := (if (n < length(pretty.cpstack)) (pretty.cpstack[n + 1] as port)
               else port!()),
        p2 := use_as_output(p1) in
      (pretty.cprevious := n, 
       pretty.cpretty := p1,
       if (pretty.cpstack = nil) pretty.cpstack := list<port>(p2,p1)        // initialisation
       else (pretty.cpstack[n] := p2,
             if (n = length(pretty.cpstack)) pretty.cpstack :add p1)) ]


;pretty.cprevious := use_as_output(pretty.cpretty),
;    if (pretty.cprevious = pretty.cpretty)
;     error("[123] YOU ARE USING PRINT_in_string_void RECURSIVELY") ]

[end_of_string() : string
  -> if (pretty.cprevious = 0) error("[123] unbalanced use of print-in-string"),
     let n := pretty.cprevious,
         s := string!(pretty.cpretty), 
         p := (pretty.cpstack[n]) as port in
       (set_length(pretty.cpretty, 0),
        use_as_output(p),
        pretty.cpretty := p,
        pretty.cprevious :- 1,
        s) ]

[buffer_length() : integer
  -> length(pretty.cpretty) ]


[buffer_set_length(i:integer) : void
  -> set_length(pretty.cpretty,i) ]

// a method for calling the printer without issuing a message
// here we assume that self_print is always defined as a function
[apply_self_print(self:any) : void
 -> case self
      (thing princ(self.name),
       class princ(self.name),
       integer princ(self),
       string self_print(self),
       any let %prop := (self_print @ owner(self)) as method in
             (if (%prop & known?(functional, %prop))
                 let l := %prop.srange in
                   funcall(%prop.evaluate, (l[1] as class), self,
                           (l[2] as class))
              else try self_print(self)
                   catch any printf("<unprintable:~S>", owner(self)))) ]

// some basic definitions
[self_print(self:any) : void
 ->  if (self = unknown) princ("unknown")
     else let c := owner(self), n := length(c.params) in
        (if (n > 0)
            printf("~S(~I)",c,
                   for i in (1 .. n) (print(get(c.params[i],self)), if (i < n) princ(",")))
         else printf("<~S>", c)) ]

[self_print(self:boolean) : void
 -> if self princ("true") else princ("false") ]

[self_print(self:function) : void -> printf("#'~A", string!(self)) ]

// prints the name of a restriction. If we have a close property and if a
// short-cut is possible, we use it.
self_print(self:restriction) : void
 -> (if (not(known?(selector, self)) | unknown?(domain, self))
        printf("<~S>", owner(self))
     else let p := self.selector,
              n := 0,
              c := domain!(self) in
            (for r in p.restrictions (if (domain!(r) = c) n :+ 1),
             printf("~A @ ~S", p.name, (if (n = 1) c else self.domain))))

// we are too far
much_too_far <: error()
print(x:any) : void
 -> (if (pretty.pbreak & pretty.pprint)
        let b_index := buffer_length(), missed := false, %l := pretty.index in
          (if not(short_enough(b_index + 10))
              (pretty.pprint := false, pretty.pbreak := false,
               print(x), pretty.pprint := true)
           else (try (pretty.pbreak := false,
                      apply_self_print(x),
                      pretty.pbreak := true)
                 catch much_too_far (missed := true),
               if missed (pretty.pprint := true, pretty.pbreak := true,
                          buffer_set_length(b_index),
                          pretty.index := %l,
                          apply_self_print(x))))
     else apply_self_print(x),
     unknown)

short_enough(self:integer) : boolean -> (self < pretty.width)


// *********************************************************************
// *   Part 2: Methods for CLAIRE objects                              *
// *********************************************************************

// the instantiation body is a sequence of words from which the initialization
// of the object must be built.
//  copied_def = object (for object) + float (for float) + integer (for all)
//               + NULL for objects
// v3.2.12: use a condition that is coherent with ClReflect.cl : a slot defaut value must be placed
// unless it is a copied_def
complete!(self:object) : object
 -> (for s:slot in self.isa.slots
       let p := s.selector,
           s2 := s.srange,
           d := get(default, s) in
         (if known?(d)
             let v := slot_get(self, s.index, s.srange) in
               (if (unknown?(v) & not(s2 = object | d % integer | s2 = float))   // v3.2.12 coherence
                   // was: (s2 = any & not(d % integer) & unknown?(v))
                   update(p, self, s.index, s.srange, d)
                else if (d = v)
                   (if (p.multivalued? != false) for y in d update+(p, self, y)
                    else update+(p, self, d)))),
     let m := (close @ owner(self)) in
       (case m (method funcall(m, self) as object,
                any self)))  // v3.0.41  obviously



//-------------------------- ENTITY   --------------------------------------
claire/kill! :: property()
claire/kill!(self:any) : any -> function!(kill_I_any)

;object?(self:any) : boolean -> (if (self % object) true else false)
;Ftuple?(self:any) : boolean -> (if (self % tuple) true else false)

not(self:any) : boolean
  -> (if (self = true) false
      else if (self = false) true
      else if not(self) true
      else false)
!=(self:any,x:any) : boolean -> (if (self = x) false else true)

// gives the type of any object. This is open_coded.
owner(self:any) : class -> owner(self)

// some useful methods
known?(self:any) : boolean -> (unknown != self)
unknown?(self:any) : boolean -> (unknown = self)

// needed by the compiled code
check_in(self:any,y:type) : any
 -> (if (self % y) self
     else error("[124] the value ~S does not belong to the range ~S", self, y))

check_in(self:bag,c:class,y:type) : bag
 -> (if forall(z in self | z % y) cast!(self,y)
     else error("[124] the value ~S does not belong to subtype[~S]",self, y))

// new in v3.00.48
<(self:any,x:any) : boolean -> (if (self = x) false else (self <= x))
>(self:any,x:any) : boolean -> (if (self = x) false else (x <= self))
// >= is defined as a macro in file.cl


// ----------------------- CLASS ---------------------------------------------

// declares a class as ephemeral: the member set is not maintained
// v3.2.14 recusively applies to subclasses
ephemeral(self:class) : any
  -> (for c in self.descendents
       (if (c.instances | c.open <= 1)
           error("[187] cannot declare ~S as ephemeral because of ~S",self,c)
        else put(open, c, system.ephemeral)))

// declares a class as an abtract class (without instances)
abstract(c:class) : any
 -> let n := c.open in
       (if (n = system.ephemeral) error("[125] ephemeral classes cannot be abstract")
        else (if (length(c.instances) != 0)
                 trace(3, "--- note: ~S already has some instances", c),
              if (n = 2) write(open, c, 0)
              else if (n = 1) write(open, c, -1)),
        c)

// declares a class as totally defined in the hierarchy: no new subclasses can be added.
final(c:class) : any
 -> let n := c.open in
       (if (n = 3) error("[126] ephemeral classes cannot be set as final")
        else if (n = 2) write(open, c, 1)
        else if (n = 0) write(open, c, -1),
        c)

//instantiation with and without a name
new(self:class) : type[object glb member(self)]
  -> let o := (if (self.open <= 0) error("[105] cannot instantiate ~S", self),  // v3.2.44
               new!(self)) in
        (if (self.open != ephemeral()) add!(instances, self, o),                // v3.2.34
         complete!(o))                                                          // v3.2.26
        
new(self:class,%nom:symbol) : type[thing glb member(self)]
   -> let o := (if (self.open <= 0) error("[105] cannot instantiate ~S", self),  // v3.2.44
                new!(self,%nom)) in
       (complete!(o) as thing)      // v3.2.26

// internal version
mClaire/new!(self:class) :  type[object glb member(self)]
  -> function!(new_object_class, NEW_ALLOC)
mClaire/new!(self:class,%nom:symbol) :  type[thing glb member(self)]
   -> function!(new_thing_class, NEW_ALLOC)

// the smallest super_set of two sets
// there is always any, so it always returns a class
meet(self:class,ens:class) : class
 -> (let l1 := self.ancestors,
         l2 := ens.ancestors,
         m := (if (length(l1) < length(l2)) length(l1) else length(l2)) in
       (while (l1[m] != l2[m]) m :- 1, l1[m] as class))

// fast inclusion method for lattice_sets (lattice order). The argument is
// either a lattice_set or {}
inherit?(self:class,ens:class) : boolean
 -> (let l := self.ancestors,
         n := length(ens.ancestors) in
       (n <= length(l) & l[n] = ens))


class!(s:symbol,c:class) : class -> function!(class_I_symbol,NEW_ALLOC)


//------------- PROPERTY ---------------------------------------------------

// the two methods to access open(r)
// an abstract property is extensible and can receive new restrictions
abstract(p:property) : any
 -> let n := p.open in
       (if (n < 2) error("[127] ~S can no longer become abstract", p)
        else write(open, p, 3),
        p)

// a final property is completely defined and cannot receive a new restriction
// v3.2.04: the new value 4 will be used to represent (compiled but open)
final(r:relation) : void
 -> (case r
      (property (if (r.open <= 2)
                   (write(open, r, 1),                  // v3.2.04
                    put(domain, r,
                        Uall(list{ x.domain[1] | x in r.restrictions})),
                    put(range, r,
                        Uall(list{ x.range | x in r.restrictions}))))))


//------------- MODULES   --------------------------------------------------

// the close function gives its right value to the *internal* slot that
// is the order of the module in the system. The name is supposed to be
// read in the system module.
close(self:module) : module
 -> (if (self != claire)
        (if known?(part_of, self)
            let sup := self.part_of in
              (parts(sup) :add self,
               for x in sup.uses
                 (if (not(x % self.uses) & x % module) uses(self) :add x))
         else trace(3, "---- note: ~S is a root module !\n", self)),
     self)

// note: dynamic modules are no longer supported
claire/get_symbol(m:module,self:string) : any -> function!(get_symbol_module)
claire/get_symbol(self:string) : any -> get_symbol(claire,self)

// *********************************************************************
// *   Part 3: System Methods                                          *
// *********************************************************************

// all these methods will be open-coded by the compiler
//get_stack(self:integer) : any -> get_stack(self)
//put_stack(self:integer,x:any) : any -> put_stack(self, x)
//push!(self:meta_system,x:any) : void -> push!(self, x)

gc() : void -> function!(claire_gc)
time_get() : integer -> function!(time_get_void)
time_read() : integer -> function!(time_read_void)
time_set() : void -> function!(time_set_void)
time_show() : void -> function!(time_show)
//stat() : void -> function!(claire_stat)
gensym(self:void) : symbol -> gensym("g")

// world management
store(l:list,n:integer,y:any) : any -> store(l,n,y,true)
store(l:array,n:integer,y:any) : any -> store(l,n,y,true)
commit(n:integer) : void -> (while (n < world?()) commit())
backtrack(n:integer) : void -> (while (n < world?()) backtrack())
claire/world+ :: choice
claire/world- :: backtrack
claire/world-! :: commit

// allows to change the storage class
store(l:listargs) : any
  -> (for r in l
         case r (relation r.store? := true,
                  string let v := get_value(r) in
                          case v (global_variable v.store? := true)))


// *********************************************************************
// *   Part 4: Methods for Native entities                             *
// *********************************************************************

//------------------- STRING -----------------------------------------------
length(self:string) : integer -> function!(strlen)

make_function(self:string) : function -> function!(make_function_string)
symbol!(self:string) : symbol -> symbol!(self, claire)

;<=(s:string,s2:string) : boolean
; -> (let n := length(s),
;         m := length(s2) in
;       for i in (1 .. n)
;         (if (i > m) break(false),
;          if ((s[i] as integer) <= (s2[i] as integer))
;             (if (s[i] != s2[i]) break(true))
;          else break(false),
;          if (i = n) break(true)))

externC(s:string) : void -> error("cannot execute C code: ~A", s)
externC(s:string,c:class) : type[member(c)] -> error("cannot execute ~A",s)

nth_get(s:string,n:integer,max:integer) : char
  -> (if (n <= max) s[n] else error("Buffer string access"))
nth_put(s:string,n:integer,c:char,max:integer) : void
  -> (if (n <= max) s[n] := c  else error("Buffer string access"))
shell(self:string) : void -> function!(claire_shell)
claire/getenv(self:string) : string -> function!(getenv_string)
claire/get_value(self:string) : any -> function!(value_string)
claire/get_value(self:module,s:string) : any -> function!(value_module)  //  v3.2.14

//------------------- SYMBOL -----------------------------------------------
make_string(self:symbol) : string
 -> (print_in_string(), princ(self), end_of_string())
//princ(self:symbol) : any -> function!(princ_symbol)
self_print(self:symbol) : void -> printf("~A/~S", module!(self).name,string!(self))
//c_princ(self:symbol) : any -> function!(c_princ_symbol)
//gensym(self:string) : symbol -> function!(gensym_string, NEW_ALLOC)

//--------------------- INTEGER -----------------------------------------
+(self:integer,x:integer) : type[abstract_type(+, self, x)] -> (self + x)
-(self:integer,x:integer) : type[abstract_type(-, self, x)] -> (self - x)
//-(self:integer) : integer -> function!(ch_sign)

//float!(self:integer) : float -> function!(to_float)
//mod(self:integer,x:integer) : integer -> function!(mod_integer)
--?(self:integer,x:integer) : set -> function!(sequence_integer, NEW_ALLOC)
exit(self:integer) : void -> function!(CL_exit)
//less_code(n:integer,i:integer) : boolean -> function!(less_code_integer)
<<(x:integer,y:integer) : integer -> externC("(x << y)",integer)
>>(x:integer,y:integer) : integer -> externC("(x >> y)",integer)
and(x:integer,y:integer) : integer -> externC("(x & y)",integer)
or(x:integer,y:integer) : integer -> externC("(x | y)",integer)

// open-coded
<(self:integer,x:integer) : boolean -> (if (self < x) true else false)
<=(self:integer,x:integer) : boolean -> (if (self <= x) true else false)
>(self:integer,x:integer) : boolean -> (if (self > x) true else false)
nth(self:integer,y:integer) : boolean -> (if self[y] true else false)

claire/abs(x:integer) : integer -> (if (x >= 0) x else -(x))
claire/random(a:integer,b:integer) : integer -> (a + random(b + 1 - a))

// used by the logic
factor?(x:integer,y:integer) : boolean -> ((x mod y) = 0)
divide?(x:integer,y:integer) : boolean -> ((y mod x) = 0)
Id(x:any) : type[x] -> x
pair :: operation()
pair(x:any,y:any) : list -> list(x, y)
pair_1(x:list) : type[member(x)] -> x[1]
pair_2(x:list) : type[member(x)] -> x[2]

//------------------------ FLOAT ---------------------------------------------
self_print(self:float) : void -> function!(print_float)
+(self:float,x:float) : float -> (let y:float := (self + x) in y)
-(self:float,x:float) : float -> (let y:float := (self - x) in y)
*(self:float,x:float) : float -> (let y:float := (self * x) in y)
/(self:float,x:float) : float -> (let y:float := (self / x) in y)
-(self:float) : float -> (-1.0 * self)
sqrt(self:float) : float -> (let y := sqrt(self) in y)
^(self:float,x:float) : float
 -> (let y := 0.0 in (externC("y = pow(self,x)"), y))
claire/log(self:float) : float 
 -> (let y := 0.0 in (externC("y = log(self)"), y))
claire/sin(self:float) : float
 -> (let y := 0.0 in (externC("y = sin(self)"), y))
claire/cos(self:float) : float
 -> (let y := 0.0 in (externC("y = cos(self)"), y))

mClaire/atan(self:float) : float
 -> (let y := 0.0 in (externC("y = atan(self)"), y))
 
string!(self:float) : string -> (print_in_string(), princ(self), end_of_string())
princ(self:float,i:integer) : void -> function!(print_format_float)        // v3.3.42

claire/abs(x:float) : float -> (if (x >= 0.0) x else -(x))

// the pF is my ugly duckling :) -------------------------------------------
// float print is now standard in v3.4.42 (princ(float_integer)  but this is still a cuter print ...
mClaire/printFDigit(x:float,i:integer) : void        // prinf i numbers
  -> (if (x < 0.0) (princ("-"), printFDigit(-(x),i))
      else let frac := x - float!(integer!(x + 1e-10)) + 1e-10 in
         printf("~A.~I", integer!(x + 1e-10),
                printFDigit(integer!(frac * (10.0 ^ float!(i))),i)))

// print the first i digits of an integer
mClaire/printFDigit(x:integer,i:integer) : void
  -> (if (i > 0) let f := 10 ^ (i - 1), d := x / f in
                   (princ(d), if (i > 1) printFDigit(x mod f, i - 1)))

//--------- BAG --------------------------------------------------------
length(self:bag) : integer -> length(self)
nth(self:bag,x:integer) : type[(if (self % tuple & unique?(x)) self[the(x)]   // v3.3.22
                                else member(self))]
 -> (if (x > 0 & x <= length(self)) self[x]
     else error("[41] nth[~S] out of scope for ~S", x, self))
    
nth_get(self:bag,x:integer) : any -> nth_get(self, x)

min(f:method,self:bag) : type[member(self)]     // v3.1.08
 -> (if (length(self) != 0)
        let x := self[1] in
                 (for y in self (if (funcall(f, y, x) as boolean) x := y), x)
     else error("[183] min of empty set is undefined"))

max(f:method,self:bag) : type[member(self)]     // v3.1.08
 -> (if (length(self) != 0)
        let x := self[1] in
                  (for y in self (if not(funcall(f, y, x)) x := y), x)
     else error("[183] max of empty set is undefined"))

// there seems to be a difficulty with providing this method with the proper type ..
/+(x:bag,y:bag) : list // TODO type[list[member(x) U member(y)]]
 -> let l := (case x (list copy(x), set list!(x), tuple list!(x))) as list in  // v3.00.10
       (case y (list l :/+ y, bag for z in y l :add z), l)

// new for claire 3.4
random(self:bag) : type[member(self)] -> let n := length(self) in self[1 + random(n)]

//--------- LIST --------------------------------------------------------
// last element of a list
last(self:list) : type[member(self)] 
  -> (if (length(self) > 0) self[length(self)] else error("[41] car(nil) is undefined"))
  
// remove the last element
rmlast(self:list) : list  -> (nth-(self,length(self)), self)

nth=(self:list,x:integer,y:any) : any
  -> (if (x <= 0 | x > length(self)) error("[41] nth[~S] out of scope for ~S", x, self) // v3.3.24
      else if (y % of(self)) self[x] := y                                              // v3.0.38
      else system_error(index = 17,arg = y, value = self))                             // v3.2.00

// the old LISP method
car(self:list) : any
 -> (if (length(self) > 0) self[1] else error("[41] car(nil) is undefined"))

// hashtable basics
[hashlist(n:integer) : list
 -> let l := make_list(n, unknown),
        u := ((nth_get(l, 0) as integer) - 3) in
       (for i in ((n + 1) .. u) l add unknown,
        l) ]

[hashsize(l:list) : integer
 -> let x := 0 in (for y in l (if (y != unknown) x :+ 1), x) ]

// this method sorts a list according to an order
sort(f:method,self:list) : list
 -> (quicksort(self, f, 1, length(self)), self)

// v3.0.38: upgrade the quicksort algorithm with a better pivot selection cf.bag.cpp
// this is also proposed as a macro: cf. file.cl
quicksort(self:list,f:method,n:integer,m:integer) : void
 -> (if (m > n)
        let x := self[n] in
          (if (m = (n + 1))
              (if (funcall(f, self[m], x) as boolean)
                  (self[n] := self[m], self[m] := x))
           else let p := (m + n) >> 1, q := n in   // new: p is pivot's position
                  (x := self[p],
                   if (p != n) self[p] := self[n],
                   for p in ((n + 1) .. m)
                     (if (funcall(f, self[p], x) as boolean)
                         (self[n] := self[p],
                          n := n + 1,
                          if (p > n) self[p] := self[n])),
                   self[n] := x,
                   quicksort(self, f, q, n - 1),
                   quicksort(self, f, n + 1, m))))

 // destructive method that build the powerset
build_powerset(self:list) : set
 -> (if (length(self) != 0)
        let x := self[1],
            l1 := build_powerset(self << 1),
            l2 := l1 in
          (for y:set in l1 l2 :add (set(x) /+ y), l2)
     else {{}})

// <<(x:list,y:integer) : list -> function!(skip_list)

[tuple!(x:list) : tuple -> function!(tuple_I_list,NEW_ALLOC)]

// new and useful (v3.1.06)
claire/make_copy_list(n:integer,d:any) : list
  -> let l := make_list(n,d) in
       (case d (bag  for i in (1 .. n) l[i] := copy(d)),
        l)

//----------------------  SET  ---------------------------------------------
difference(self:set,x:set) : set -> { y in self | not(contain?(x, y))}

//--------- ARRAY --------------------------------------------------------

nth=(self:array,x:integer,y:any) : void
 -> (if not(y % of(self)) error("type mismatch for array update ~S, ~S",y,self)
     else if (x > 0 & x <= length(self)) nth_put(self,x,y)
     else error("nth[~S] out of scope for ~S", x, self))

self_print(self:array) : void -> printf("array<~S>[~A]",of(self),length(self))
 
//---------------------- CHAR --------------------------------------------
self_print(self:char) : void -> printf("'~A'", self)
<=(c1:char,c2:char) : boolean -> (integer!(c1) <= integer!(c2))

// --------------------- BOOL -----------------------------------------------
claire/random(b:boolean) : boolean
  -> (if b (random(10000) >= 5000) else false)

// three methods that are useful for debugging !
Address(self:any) : integer -> function!(Address)
Oid(self:any) : string -> function!(Oid)
Oid~(self:string) : any -> function!(Oid_inv)


(printf("----------------- prototype of CLAIRE v2.9 compiler --------------------\n"),
 source(compiler) := "test",
 safety(compiler) := 5)

(debug())

RELEASE :: 9.0

gen :: module(source = "d:\\claire\\v2.9\\src\\compile",
              part_of = Compile,
              made_of = list("gsystem","gexp","gstat","cgen"))

;Core :: module(source = "d:\\claire\\v2.9\\src\\meta",
;               part_of = claire,
;               made_of = list("method","core","function","type"))
(source(System) := "d:\\claire\\v2.9\\src\\meta",
 source(Language) := "d:\\claire\\v2.9\\src\\meta",
 source(Reader) := "d:\\claire\\v2.9\\src\\meta",
 made_of(System) := list("method","object","function","types"))

[go() -> 
  //[0] ... generate(System)  //,
  generate(System) ]

[go1() -> 
  //[0] ... generate(Language + Reader)  //,
  generate(Language),
  generate(Reader) ]//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| inspect.cl                                                  |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------------
// this file contains the CLAIRE run-time tools: inspect, trace & debug
// --------------------------------------------------------------------

// *********************************************************************
// * Contents                                                          *
// *      Part 1: Inspection                                           *
// *      Part 2: Trace                                                *
// *      Part 3: Debugger                                             *
// *      Part 4: Stepper & Measure                                    *
// *      Part 5: Profiler                                             *
// *********************************************************************

execute_do :: property()
execute_bk :: property()
inspect_loop :: property()
get_from_integer :: property()
top_debugger :: property()

// a useful global variable *last*
*last*:any := unknown
*index*:integer := unknown
*maxd*:integer := unknown
*curd*:integer := 0                     // v3.2.14 cleaner :-)
*showall*:boolean := true               // v0.01 stop the ... !

// this is the interface with the system
//
inspect_system(l:list) : any -> function!(InspectLoop)
debug_system() : any -> function!(DebugLoop)
step_system() : integer -> function!(StepLoop)
CommandLoop() : string -> function!(CommandLoopVoid)

// *********************************************************************
// *      Part 1: Inspection                                           *
// *********************************************************************
// this is the method that the user calls
//
inspect(self:any) : any
 -> let %read:any := {}, m0 := module!(), ix := 0 in
       (case self
         (bag for i in (1 .. length(self)) printf("~A: ~S\n", i, self[i]),
          object for rel in owner(self).slots
                  let m := module!(name(selector(rel))) in
                    (ix :+ 1,            // ix is the position in the slots list
                     if (m = m0 | m = claire | *showall*)
                       let val := get(rel,self) in
                        printf("~A: ~S = ~I\n", ix, rel.selector,
                           (case val (bag (if (length(val) < 10) pretty_print(val)
                                           else (pretty_print(
                                                   list{val[i] | i in (1 .. 9)}),
                                                 pretty_print("..."))),
                                      any pretty_print(val))))),
          any printf("~I\n", pretty_print(self))),
        inspect_system(list(self)),
        None)

// this is the inspect top_level
//
inspect_loop(%read:any,old:list) : any
 -> (let self:any := old[1] in
       (if (case %read (Call %read.selector = put))
           let n:integer := %read.args[1],
               s:symbol := extract_symbol(%read.args[2]) in
             (if not(n % integer) error("[128] ~S should be an integer", n),
              let val := get_from_integer(self, n) in
                (put(value, new(global_variable, s), val),
                 inspect(val),
                 old := val cons old))
        else if (%read = up)
           (if (length(old) > 1) (old := cdr(old), inspect(old[1])))
        else if (%read % integer)
           let val := get_from_integer(self, %read) in
             (old := val cons old, inspect(val))
        else if (%read % thing) (old := %read cons old, inspect(%read))
        else printf("=> given to inspector is wrong.\n")),
     inspect_system(old))

// get the information bound to the index
//
get_from_integer(self:any,n:integer) : any
 -> (if (self % bag)
        (if (n > 0 & n <= length(self)) self[n]
         else (printf("~A in not a good index for ~S.\n", n, self), self))
     else let l := owner(self).slots in
            (if (n > 0 & n <= length(l)) get@slot(l[n], self)
             else (printf("~A is not a good index for ~S.\n", n, self),
                   self)))

// *********************************************************************
// *      Part 2: Trace methods                                        *
// *********************************************************************
// instrument the code generated from the rules

trace_on(self:any) : any
 -> (case self
      (property (if (self = spy)
                   let m := (spy @ void) in (if m put(Kernel/spy!, system, m))      ;*/
                 else if (self = where) system.Kernel/call_count := 1
                 else put(trace!, self, 5 - system.verbose)),
       environment put(trace!, system, 1),
       module (if (self.mClaire/status > 2) self.mClaire/status := 4,
               for m in self.parts trace_on(m)),
       port put(ctrace, system, self),
       string put(ctrace, system, fopen(self, "w")),
       integer put(verbose,system,self),
       any error("[129] trace not implemented on ~S\n", self)),
      self)

untrace(self:any) : any
 -> (case self
      (property (if (self = spy) put(Kernel/spy!, system, unknown)
                 else if (self = where) system.Kernel/call_count := -1
                 else put(trace!, self, 0)),
       environment put(trace!, system, 0),
       module (if (self.mClaire/status = 4) self.mClaire/status := 3,
               for m in self.parts untrace(m)),
       port put(ctrace, system, stdout),
       any error("[130] untrace not implemented on ~S\n", self)),
      self)

// a filter to restrict the impact of spy
// we put the special value nil (emply list of demons => OK) to mark that spying
// should be waken up on properties from l
spy(l:listargs)  : void
  -> (let m := (spy @ void) in
       (if m (put(Kernel/spy!, system, m),                   ;*/
              for f in property (if (f % l) f.mClaire/if_write := nil))))


// note: trace behavior for output statements defined in CLAIRE1 (self_eval)
self_trace(self:Trace) : any
 ->  let a := self.args in
       (if (length(a) = 1)
           let a1 := eval(a[1]) in
             (if (system.trace! = 0) put(trace!, system, 1), trace_on(a1))
   ;     else if (length(a) = 2 & a[2] % integer & (a[1] % ({spy} U integer)))
   ;          (system.Kernel/call_level := a[2], system.Kernel/call_trigger := a[1])
        else self_eval(self))

(let x := get(functional, self_trace @ Trace) in
  (if known?(x) put(mClaire/evaluate, Trace, x)))

// used to trace the trigger of a rule
//
trace_rule(R:relation,s:string,x:any,y:any,u:any,v:any) : void
 -> (if ((mClaire/if_write.trace! + system.verbose) >= 5)
        let p := get(ctrace, system) in
          (if known?(p) p := use_as_output(p),
           printf("--- the rule ~A is triggered for (~S,~S) by an update ~S(~S) ~A ~S \n",
                  s, u, v, R, x, (if multi?(R) ":add" else ":="), y),
           if known?(p) use_as_output(p)))


// stores a set of stopping values
stop(p:property,l:listargs) : any
  ->  (if unknown?(Core/StopProperty,p) Core/StopProperty[p] := list(l)
       else if (l = nil) put(Core/StopProperty,p,unknown)
       else Core/StopProperty[p] :add list(l),
       true)


// ******************************************************************
// *    Part 3: The debugger interface                              *
// ******************************************************************

// toggle the debug mode
debug(system) : void
 -> (if (system.Kernel/debug! != -1)
        (write(Kernel/debug!, system, -1), printf("debugger removed\n"))
     else (write(Kernel/debug!, system, 0),
           put(ctrace, system, stdout),
           printf("debugger installed\n")))

// this method is called when an error has occured. The value of index
// is recalled with last_index, so that the actual content of the stack is
// preserved.
call_debug(system) : any
 -> (let top := system.Kernel/last_debug in
       (debug_system(),
        put(Kernel/spy!, system, unknown),       ;*/
        write(step!, system, 0),
        write(trace!, system, 0),
        mClaire/set_base(system.Kernel/last_index),
        mClaire/set_index(+@integer(system.Kernel/last_index, 1)),
        put(Kernel/debug!, system, top),
        print_exception(),
        write(fromp, reader, stdin),
        write(index, reader, 0),
        when c := Language/LastCall in
            try (if (DBline[c] > 0) printf(" \n---- Last call ~S in line ~A\n",c,DBline[c]))
            catch any nil,
        *index* := 1,
        *curd* := system.Kernel/debug!,
        *maxd* := system.Kernel/debug!))

// this method is called when an error has occured. The value of index
// is recalled with last_index, so that the actual content of the stack is
// preserved.
breakpoint() : void
 -> (let top := system.Kernel/debug!,
         s := system.step!,
         t := system.trace! in
       (write(step!, system, 0),
        write(trace!, system, 0),
        *index* := 0,
        *curd* := top,
        *maxd* := top,
        if (mClaire/get_stack(top) > 0 & system.Kernel/debug! > 0)
           let j := mClaire/get_stack(top),
               num_args := (mClaire/get_stack(j + 2) - 1),
               start := (mClaire/get_stack(j + 3) as integer),
               m := mClaire/get_stack(j + 1) in
            (printf("break in ~S(~S~I) [q] >", m,
                    mClaire/get_stack(start),
                    (for i in ((start + 1) .. (start + num_args))
                       printf(",~S", mClaire/get_stack(i)))),
             let n := 1,
                 m := 1,
                 c:any := read(CommandLoop()) in
              while (c != q) (eval(c),
                              princ("break>"),
                              c := read(CommandLoop()))),
        write(step!, system, s),
        write(trace!, system, t)))

// the four keyword
up :: property()
dn :: property()
where :: property()

[dn(x:integer) : void
 -> while (mClaire/get_stack(*curd*) > 0 & x > 0)
       (*curd* := mClaire/get_stack(*curd*), *index* :+ 1, x := x - 1) ]

[up(x:integer) : void
 ->  if (x > 0)
        let indices := nil,
            ind := *maxd* in
          (while (ind != *curd*)
             (indices := ind cons indices, ind := mClaire/get_stack(ind)),
           if (x > length(indices)) (*curd* := *maxd*, *index* := 1)
           else (*curd* := indices[x], *index* :- x)) ]

// top is the top position in this stack (the last entered message)
[where(x:integer) : void
 ->  let j := *curd*,
         stack_level := 0 in
       while (j > 0 & x > 0 & system.Kernel/debug! > 0)
         (print_debug_info(j, stack_level, *index*),
          stack_level :+ 1,
          x := x - 1,
          j := (mClaire/get_stack(j) as integer)) ]

// note for interpretted methods .. they should be pushing their restriction
// on the stack vs. properties
print_debug_info(index:integer,stack_level:integer,cur_index:integer) : void
 -> (let num_args := ((mClaire/get_stack(index + 2) as integer) - 1),
         start := (mClaire/get_stack(index + 3) as integer),
         m := mClaire/get_stack(index + 1) in
       printf("debug[~A]>~I ~S(~S~I)\n", cur_index + stack_level,
              (for x in (1 .. stack_level) printf(">")), m,
              mClaire/get_stack(start),
              (for i in ((start + 1) .. (start + num_args))
                 printf(",~S", mClaire/get_stack(i)))))

// debug version of the debugger :-)
Show(n:integer) : any
 -> let i := *curd* in          // i = top of stack
       (while (i > 0 & n > 0)
         let num_args := ((mClaire/get_stack(i + 2) as integer) - 1),
             start := (mClaire/get_stack(i + 3) as integer) in
           (printf("[~A - ~A]: p = ~S, narg = ~S \n", start, i,
                   mClaire/get_stack(i + 1), num_args),
            for j in (0 .. num_args)
              printf("  [~A]:~S \n", j + i, mClaire/get_stack(j + i)),
            n :- 1,
            i := (mClaire/get_stack(i) as integer)))         // go to next block

// top is the top position in this stack (the last entered message)
//
claire/block(x:integer) : void
 -> let j := *curd*,
         stack_level := 0 in
      (while (j > 0 & x > 0 & system.Kernel/debug! > 0)
         (let nargs := mClaire/get_stack(j + 2),
              start := (mClaire/get_stack(j + 3) as integer),
              z := mClaire/get_stack(j + 1) as property,
              m := Core/find_which(z.Kernel/definition,
                                    owner(mClaire/get_stack(start)), start,
                                    start + nargs) in
          (case m (method
              printf("debug[~A] > ~S(~I)\n", *index* + stack_level, m,
                   (if (known?(formula,m) & m.formula % lambda)
                       let n := 0 in
                         for v in closure_build(m.formula)
                           (printf("~S = ~S, ", v, mClaire/get_stack(start + n)),
                            n :+ 1)
                    else printf("<compiled:~S>", m.module!))),
                   any printf("debug[~A] > ~S -> ~S\n", *index* + stack_level,z,m))),
          stack_level :+ 1,
          x :- 1,
          j := (mClaire/get_stack(j) as integer)))

// computes the list of variables of a lambda, including everything
//
closure_build(self:lambda) : list
 -> (let lvar := make_list(self.dimension, {}) in
       (for x in self.vars lvar[x.index + 1] := x,
        closure_build(self.body, lvar),
        lvar))

// give to each lexical variable its right position in the stack
// answer with the number of lexical variable
//
closure_build(self:any,lvar:list) : void
 -> (case self
      (Variable lvar[self.index + 1] := self,
       Instruction for s in self.isa.slots
                    closure_build(get(s, self), lvar),
       bag for x in self closure_build(x, lvar),
       any nil))

// ******************************************************************
// *    Part 4: Stepper, Measure & mem                              *
// ******************************************************************
// the stepper interface is quite simple and could be improved
//
[Core/call_step(pr:property) : void
 ->  printf(") : [(i)n,(o)ut,e(x)it,(t)race,(b)reakpoint]\n"),
     let m := 1,
         c := char!(step_system()),
         n := system.step! in
       (if (c = 'i') write(step!, system, n + 1)
        else if (c = 'o') (if (n > 1) write(Kernel/step!, system, n - 1))
        else if (c = 'x') error("exit stepper")
        else if (c = 't') trace_on(pr)
        else if (c = 'b') breakpoint())]

// interface
// step => trace
//
claire/step(x:any) : void
 -> (if (system.trace! = 0) write(trace!, system, 1),
     case x
      (property write(trace!, x, x.trace! + 1000),
       integer (system.Kernel/count_trigger := step, system.Kernel/count_level := x),
       environment (if (system.step! = 0)  system.step! := system.trace!
                    else system.step! := 0),
       any 0))

// New in CLAIRE 3.4 - measure objects can be stored on a file and loaded later on
// a measure is a float value counter that stores the sum & sum of squares, to 
claire/measure <: object(
  m_index:integer = 1,          // each measure has an index
  sum_value:float = 0.0,        // keep sigma(values) to return average
  sum_square:float = 0.0,       // used for standard deviation
  num_value:float = 0.0)        // number of experiments

// simple methods add, mean, stdev
[close(x:measure) : measure 
  -> (x.m_index := length(measure.instances), x)]
[add(x:measure, f:float) : measure 
  -> x.num_value :+ 1.0, x.sum_value :+ f, x.sum_square :+ f * f, x ]
[claire/mean(x:measure) : float 
  -> if (x.num_value = 0.0) 0.0 else x.sum_value / x.num_value]
[claire/stdev(x:measure) : float
   -> let y := ((x.sum_square / x.num_value) - ((x.sum_value / x.num_value) ^ 2.0)) in
         (if (y > 0.0) sqrt(y) else 0.0) ]
[claire/stdev%(x:measure) : float -> stdev(x) / mean(x) ]
[claire/reset(x:measure) : void -> x.sum_square := 0.0, x.num_value := 0.0, x.sum_value := 0.0 ]
[self_print(m:measure) : void -> printf("~F2[~F0]",mean(m),m.num_value)]


// two simple methods to store and retreive measures
//   logMeasure(s:string)  : creates a file
//   load(s:string)        : loads the files, that containts addLog(i,s,ss,n) line
[claire/logMeasure(s:string) : void
  -> let p := fopen(s,"w"),n := size(measure) in
       (use_as_output(p),
        printf("// log file produced on ~A",date!(1)),
        for m in measure 
           printf("(addLog(~A,~A,~A,~A,~A))\n",m.m_index,m.sum_value,m.sum_square,m.num_value,n),
        fclose(p)) ]

// adds a set of measures to a measure object (represented by its index)
[claire/addLog(i:integer,x:float,y:float,n:float,s:integer) : void
  -> (if (size(measure) = s)
        let m := measure.instances[i] in   // i <= s by construction
           (m.sum_value :+ x, m.sum_square :+ y, m.num_value :+ n)
      else error("logMeasure not compatible with current set (~A vs ~A)",size(measure),s)) ]


// memory usage statistics for a class (useful for debug)
mem(c:class) : integer
  -> let n := 0 in
       (for x in c.instances
          (n :+ slot_get(x,0,integer),         // size of chunk
           for sl in c.slots
             let rs := sl.range in
               (if (rs = float) n :+ 5
                else if (rs = string)
                  (when st := get(sl,x) in 
                    n :+ min(5, length(st as string) / 2))    // upper bound !
                else if (rs <= bag)
                  (when l := get(sl,x) in
                    n :+ nth_get(l as bag,0)))),    
        n)



// *********************************************************************
// *      Part 5: Profiler                                             *
// *********************************************************************

// we use a counter object for the 5 interesting values  and
// we use the reified slot to store the counter (thus no profiling on reified)
claire/PRcount <: object(rtime:integer = 0,     // time that has elapsed in the property
                         rdepth:integer = 0,    // counter of recursion (only register 1st)
                         rnum:integer = 0,      // number of calls
                         rloop:integer = 0,     // counter of loops
                         rstart:integer = 0)    // start time (1st entry)

// get & create if needed a PRcounter
claire/PRget(p:property) : PRcount
 -> let x := p.reified in
     (if (owner(x) = PRcount) (x as PRcount)
      else if (x = true) error("[131] Cannot profile a reified property ~S",p)
      else (x := PRcount(), p.reified := x, x as PRcount))

// get & create if needed a PRcounter
claire/PRlook(p:property) : any -> show(PRget(p))

// show the profiler statistics on one property
claire/PRshow(p:property) : void
 -> let x := p.reified in
      (case x (PRcount printf("~S: ~A calls -> ~A clock tics\n",p, x.rnum, x.rtime)))

// elapsed time
claire/PRtime(p:property)  : integer
 -> let x := p.reified in
      (case x (PRcount x.rtime, any 0))

claire/PRcounter(p:property)  : integer
 -> let x := p.reified in
      (case x (PRcount x.rnum, any 0))


// show the profiler statistics on the 10 most important properties
claire/PRshow() : void
 -> let l := list<property>() in
      (for p in property
        (if exists(i in (1 .. min(10,length(l))) |
                    (if ((PRtime(p) > PRtime(l[i])) |
                         (PRtime(p) = PRtime(l[i]) & PRcounter(p) > PRcounter(l[i])))
                        (l := nth+(l,i,p), true))) nil
         else if (length(l) < 10) l :add p),
       shrink(l,10),
       for p in l
          (if (PRcounter(p) > 0)
              (printf("-----------------------------------\n"),
               PRshow(p),
               for p2 in PRdependent[p]
                  (if (PRtime(p2) > 0) printf("   * ~I",PRshow(p2))))))

// reuse from lexical_build in pretty.cl
// returns the list of properties that are used by a method
PRdependent[p:property] : set[property] := set<property>()
PRdependentOf[p:property] : set[property] := set<property>()
dependents(self:method) : set[property] //
 -> set<property>{p in dependents(self.formula.body) |
                  exists(r in p.restrictions | r % method)}

// this is really cute ....   v3.2.58: fix typing
dependents(self:any) : any
 -> (case self
       (Call add(dependents(self.args),self.selector),
        Instruction let s := set<property>() in
                      (for sl in self.isa.slots
                         s := s U dependents(get(sl, self)),
                       s),
         bag let s := set<property>() in
                (for x in self s := s U dependents(x),
                 s),
         property set<property>(self),
         any set<property>()))

// used to set up the dependence
(PRdependent.inverse := PRdependentOf)
claire/PRdepends(p:property,p2:property) : void
 -> (PRdependent[p] :add p2, unknown)

// end of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| method.cl                                                   |
//| Copyright (C) 1994 - 2003 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file  object.cl: about()              |
//+-------------------------------------------------------------+


// ---------------------------------------------------------------------
// This file contains the reflective description of the most primitive
// CLAIRE kernel: the embryo of the class hierarchy and a set of methods
// to read/write objects and to evaluate messages.
// ---------------------------------------------------------------------

// *********************************************************************
// *  Table of contents                                                *
// *      Part 1: Lambda & Methods Evaluation                          *
// *      Part 2: Update methods                                       *
// *      Part 3: Management of definition(p)                          *
// *      Part 4: Matching Methods                                     *
// *********************************************************************

// *********************************************************************
// *      Part 1: Lambda & Methods Evaluation                          *
// *********************************************************************

// explicit definition
vars :: property()
dimension :: property()
claire/version :: property()

claire/ephemeral_object <: object()                            // a root
claire/lambda <: object(vars:list,body:any,dimension:integer)

(set_range(formula,method,lambda),
 ephemeral(ephemeral_object),
 final(method))

// explicit definition of the functions that are used in method [to avoid out_of-place
// implicit definitions]
execute :: property()
debug :: property()
eval_message :: property()
noeval_message :: property()
eval :: property()
call :: property()
self_eval :: property()
read :: property()
inlineok? :: property()
restore_state :: property()
hold? :: property()
write :: property()
range_is_wrong :: property()
update+ :: property()
update- :: property()
add_value :: property()
known? :: property()
unknown?  :: property()
erase :: property()
set_range  :: property()
put_store :: property()
matching? :: property()
vmatch?  :: property()
tmatch? :: property()
find_which :: property()
claire/main :: property()

// the eval_message is a method that tells how to handle the message.
// it used to be distributed in CLAIRE (so that it was extensible) and each
// definition was called the behavior of a kind of restriction
// int? tells us if this is an interpreted message
eval_message(self:property,r:object,start:integer,int?:boolean) : any
 -> (if (r.isa = method)
       (if (system.debug! != -1) execute(r as method,start, int?)
        else let m:method := (r as method) in
          (if known?(formula,m)
            let retour := base!() in
              (set_base(start),
               stack_apply(m.formula.dimension),
               let val := eval(m.formula.body) in
                  (set_base(retour),                   // to change ....
                   set_index(start),
                   val))
           else  stack_apply(m.evaluate, m.srange, start, index!())))
    else if ( owner(r) = slot & index!() = (start + 1))
               let val := get(r as slot, get_stack(start) as object) in
                 (if (unknown?(val) & not(val % range(r as slot)))
                     read_slot_error(arg = get_stack(start), wrong = self),
                  set_index(start),
                  let n := trace!() in
                    (if (n > 0 &
                         ( trace!(self) + verbose() > 4 | n = step!()) )
                      (put(trace!, system, 0),
                       printf("read: ~S(~S) = ~S\n",self,get_stack(start),val),
                       put(trace!, system, n))),
                  val)
    else noeval_message(self,start))


noeval_message(self:property, start:integer) : any
  -> let l := get_args(start) in
       (if (system.debug! != -1) push_debug(self, index!() - start, start),
        selector_error(selector = self, arg = l),
        nil)


// a generic method : same as previously but (1) can be called by other methods
// and (2) takes care of the debugging piece, which implies a slower run (GC)
execute(self:method,start:integer,int?:boolean) : any
 -> (let val := unknown,
         n := length(self.domain) in
       (if known?(formula, self)
           let retour := base!(),
               st? := (system.debug! != -1 & (int? | self.module!.status != 4)) in
             (set_base(start),
              stack_apply(self.formula.dimension),
              if st? push_debug(self.selector, n, start),
              val := (eval(self.formula.body) as integer),   // do not protect ...
              if st? pop_debug(self.selector, 0, val),
              set_base(retour),
              set_index(start),
              if (system.debug! != -1 & not(val % self.range))     // v3.2.01 
                 range_error(cause = self, arg = val, wrong = self.range), 
              val)
        else let st? := (system.debug! != -1 &
                         (int? | self.module!.status != 3) &
                         self.selector != debug),
                 i := index!() in
               (if st? push_debug(self.selector, n, start),
                val := stack_apply(self.evaluate, self.srange, start, i),
                if st? pop_debug(self.selector, 0, val),
                if (system.debug! != -1 & not(val % self.range))    // v3.2.01
                   range_error(cause = self, arg = val, wrong = self.range), 
                val)))

// the evaluator is open coded
eval(self:any) : any -> eval(self)

// this is the standard evaluation
self_eval(self:object) : any -> self

// evaluation for a list or enumeration
(let f := function!(self_eval_ClaireObject) in
  for x in class.instances put(Kernel/evaluate, x as class, f))

// reads an inline definition for a method
[inlineok?(self:method,s:string) : method
 -> try let p := read,
            l := call(p, s) in
        (self.inline? := true, self.formula := l)
     catch any trace(0,"---- WARNING: inline definition of ~S is wrong\n", self),
     self ]

// ****************************************************************
// *    Part 2: Update methods                                    *
// ****************************************************************

//get/put for a slot: should be inline
get(s:slot,x:object) : any -> slot_get(x, s.index, s.srange)
put(s:slot,x:object,y:any) : any
 -> store(x, s.index, s.srange, y, s.selector.store?)

// reading a value from a property (unknown is allowed)
get(self:property,x:object) : any
 -> (let s := (self @ owner(x)) in
       case s (slot slot_get(x, s.index, s.srange), any unknown))

// a more general value that is useful for types
funcall(self:property,x:any) : any
 -> (let s := (self @ owner(x)) in
       case s (slot slot_get(x as object, s.index, s.srange),
               method funcall(s,x),
               any unknown))

// reading a value from a property (unknown is not allowed)
read(self:property,x:object) : any
 -> (let s := (self @ owner(x)) in
       case s
        (slot let z := slot_get(x, s.index, s.srange) in
                (if (known?(z) | z % s.range) z
                 else read_slot_error(arg = x, wrong = self)),
         any read_slot_error(arg = x, wrong = self)))

// verifying
hold?(self:property,x:object,y:any) : boolean
 -> (let s := (self @ owner(x)) in
       case s
        (slot let z := slot_get(x, s.index, s.srange) in
                case z (set contain?(z, y), any y = z),
         any false))

// writing a single value into a slot & trigger rules
//  write = check + put + put_inverse + propagate
//  if_write = put + put_inverse + propagate  (propagate => if_write)
//  update = put + put_inverse
write(self:property,x:object,y:any) : void
 -> (let s := (self @ owner(x)) in
       case s
        (slot (if not(y % s.range) range_is_wrong(s, y)
              else if (self.open < 1 &
                       known?(slot_get(x, s.index, s.srange)))
                 error("[132] Cannot change ~S(~S)", self, x)
              else if (known?(if_write,self) & not(multi?(self))) 
                 fastcall(self,x,y)
              else update(self, x, s.index, s.srange, y)),
         any selector_error(selector = self, arg = list(x))),
     y)

// the value does not belong to the range: error!
range_is_wrong(self:slot,y:any) : any
 -> range_error(cause = self, arg = y, wrong = self.range)

// to remove
[put(p:property,x:object,n:integer,s:class,y:any) : void
 -> //[0] are you still using this dead thing (put instead of update) ??? !! //,
    update(p,x,n,s,y) ]

// update (method called by the compiler)     // v3.0.20: renamed from put !
// update = put + put_inverse  (complex links)
// update uses two satellite methods: update+ and update-
update(p:property,x:object,n:integer,s:class,y:any) : void
 -> let old := slot_get(x, n, s) in
       (if (p.multivalued? != false)
           (if (length(old) > 0)
               let v := (if (p.multivalued? = true) set() else list()) in
                 (if (of(old) != void) cast!(v,of(old)),
                  store(x, n, s, v, p.store?)),
            when r := get(inverse, p) in for z in (old as bag) update-(r, z, x),
            for z in (y as set) add!(p, x, n, z))
        else if (old != y)
           (when r := get(inverse, p) in
                (if (known?(old) & (r != p | x != old)) update-(r, old, x)),
            store(x, n, s, y, p.store?),
            update+(p, x, y)),
        y)

// this method checks the correctness of the inverse from a global view.
update+(self:relation,x:any,y:any) : void
 -> let r := self.inverse in
       (if (known?(r) & (r != self | x != y))
           (case r
             (property let s := (r @ owner(y)) in
                         case s
                          (slot
                             let old_y := get(s, (y as object)) in
                               (if (r.multivalued? != false)
                                   add_value(r, (y as object), s.index, old_y, x)
                                else store(y, s.index, s.srange, x, r.store?)),
                           any error("[133] Inversion of ~S(~S,~S) impossible", self, x, y)),
              table let old_y := get(r,y),
                        i := get_index(r, y) in
                      (if (r.multivalued? != false) add_value(r, i, old_y, x)
                       else (if known?(old_y) update-(self, old_y, y),
                             store(r.graph, i, x, r.store?))))))

// this methods deletes a value in the inverse of a global_relation
update-(r:relation,x:any,y:any) : void
 -> (case r
      (property let s := (r @ owner(x)) in
                  case s
                   (slot let l := get(s, x),
                             v := (case l
                                    (bag (if r.store? copy(l) else l) delete y,
                                     any  unknown)) in
                           put(s, x, v)),
       table let l := get(r,x), i := get_index(r, x),
                 v := (case l (bag (if r.store? copy(l) else l) delete y,
                               any unknown)) in
               store(r.graph, i, v, r.store?)))

// this methods adds a value to a multi-slot (used by the compiler)
// this is the multi-valued equivalent of update
[add!(self:property,x:object,n:integer,y:any) : void
 -> if known?(if_write,self) fastcall(self,x,y)
    else let l1 := (slot_get(x, n, object) as bag) in
       (if add_value(self, x, n, l1, y) update+(self, x, y)) ]


// this methods adds a value to a multi-slot (internal form)
// this is the multi-valued equivalent of put
[add_value(self:property,x:object,n:integer,l:bag,y:any) : boolean
 -> case l
      (set (if not(y % l)
              let l1 := (add!@set((if self.store? copy(l) else l), y)) in
                (store(x, n, object, l1, self.store?), true)
            else false),
       list (if self.store? store(l, y) else add!@list(l, y), true),
       any false) ]

// same method with error checking
[add(self:property,x:object,y:any) : void
 -> let s := (self @ owner(x)) in
       (if not(s) selector_error(selector = self, arg = list(x))
        else if not(multi?(self)) error("[134] Cannot apply add to ~S", self)
        else if (y % member((s as slot).range))
          (if known?(if_write,self) fastcall(self,x,y)
           else add!(self, x, (s as slot).index, y))
        else range_is_wrong((s as slot), y)),
     y ]

// known ?
known?(self:property,x:object) : boolean
 -> (let s := (self @ owner(x)) in
       case s (slot slot_get(x, s.index, s.srange) != unknown, any false))
unknown?(self:property,x:object) : boolean
 -> (let s := (self @ owner(x)) in
       case s (slot slot_get(x, s.index, s.srange) = unknown, any true))

// delete takes care of the inverse also
delete(self:property,x:object,y:any) : any
 -> (let s := (self @ owner(x)) in
       (if not(s) selector_error(selector = self, arg = list(x))
        else let l1 := (slot_get(x, (s as slot).index, object) as bag),
                 l := ((if self.store? copy(l1) else l1) delete y) in
               (store(x, (s as slot).index, object, l, self.store?),
                let r := self.inverse in (if known?(r) update-(r, y, x)),
                l)))

// erase is similar for mono-valued properties takes care of the inverse also
// v3.2.22: take care of multi-valued slot as well
erase(self:property,x:object) : any
 -> let s := (self @ owner(x)) in
       (if not(s) selector_error(selector = self, arg = list(x))
        else let y := slot_get(x, (s as slot).index, s.srange) in
               (if (self.multivalued? != false)
                   (when r := get(inverse,self) in for y1 in y update-(r,y1,x),
                    let l := shrink((if self.store? copy(y) else y),0) in
                      (store(x, (s as slot).index, object, l, self.store?),
                       l))
                else (store(x, (s as slot).index, s.srange, default(s), self.store?),
                      let r := self.inverse in (if (known?(r) & known?(y)) update-(r, y, x)),
                      default(s))))



[set_range(p:property,c:class,r:type) : void
 -> let s := ((p @ c) as slot) in
       (s.range := r,
        s.srange := sort!@type(r)) ]

// no longer needed because changing the range is not changing the prototype ?
// we should rather generate an error if the condition for dealing with
// defaults changes (TODO)
//        if (s.srange != any & s.srange != integer)
//           c.prototype[s.index] := 0))

// this method allows to bypass the storage mechanism - to be optimized ..
put_store(self:property,x:object,y:any,b:boolean) : void
 -> let s := (self @ owner(x)) in
      (case s
        (slot let z := slot_get(x, s.index, s.srange) in
                   (if (z != y) store(x, s.index, s.srange, y, b)),     // v3.2.04 same behavior compiled/interpreted !
         any selector_error(selector = self, arg = list(x))))


// tells if we have a multivalued relation
multi? :: property()
[multi?(x:any) : boolean
  -> case x (relation (x.multivalued? != false), any false) ]

// new: (v3.0) we have a simpler management of demons thus fastcall can be
// written in CLAIRE. A demon is either a lambda or a function, which
// arguments have precise sorts that match the relation sort
// the demon does everything: put + inverse + propagation
// thus write(R,x,y) <=> fastcall(R,x,y) <=> f(x,y)
fastcall(r:relation,x:any,y:any) : void
 -> let f := r.if_write in
      (if (f % lambda) funcall(f as lambda, x , y)
       else let c1 := sort!(r.domain), c2 := sort!(r.range) in
               funcall((f as function),c1,x,c2,y,void))



// *********************************************************************
// *   Part 3: Management of definition(p)                             *
// *********************************************************************
join :: operation()


// the dictionarty slot

// insertion in the definition tree
insert_definition(p:property,r:restriction) : void
 -> (// if (verbose() = 4) //[0] insert ~S into ~S // p,r,
     put(definition, p,
         initialize(r, class!(r.domain[1]), p.definition)))


// insert a restriction with class-domain d into a property p
initialize(x:restriction,d:class,l:list) : list
 -> let p := x.selector, ix := p.mClaire/dispatcher in
       (if (length(p.restrictions) = 5 & uniform(p))
           // dictionary = true means uniform => restrictions are stored in c.dictionary
           (for r in p.restrictions hashinsert(r),
            p.dictionary := true),
        if p.dictionary
           (if uniform(x) (if (verbose() = 4) //[0] --- hashinsert ~S // x,
                           hashinsert(x))
            else (// printf("// ---- note: ~S is not uniform because of ~S \n", p, x),  // not necessarily a bug :-)
                  p.dictionary := false)),
        if (ix > 0 & (case x (method known?(evaluate,x))))
           let c := domain!(x) in
             (if (uniform(p) & domain!(x) inherit? object)
                for c2 in c.descendents
                 (while (length(c2.mClaire/dispatcher as list) < ix)
                     add(c2.mClaire/dispatcher as list, 0),
                  if forall(y in (p.restrictions but x) |
                             (let c3 := domain!(y) in not(c2 inherit? c3 & c3 inherit? c)))
                    (c2.mClaire/dispatcher as list)[ix] := x.evaluate)
              else error("Cannot create a non-uniform restriction ~S of interface ~S",
                         x,p)),
        initialize(x, l))

// only uniform properties can use the dictionary representation
uniform(x:restriction) : boolean
 -> let l := x.domain,
         n := length(l) in
       forall(r in x.selector.restrictions |
         let l2 := r.domain in
           (l[1] % class & length(l2) = n &
            (forall(i in (2 .. n) | 
                    (l[i] = l2[i] |                   // v3.3.34
                     (owner(l[i]) != class &          // introduce a protected call to =type !
                      owner(l[i]) = owner(l2[i]) & l[i] =type? l2[i]))))))    // v3.3.36      

// v3.0.54 check that a uniform property only uses methods !
uniform(p:property) : boolean
  -> (forall(x in p.restrictions | x % method) &  uniform(p.restrictions[1]))

// insert a restriction in a list with the good order
[initialize(x:restriction,l:list) : list
 -> let l1:list := nil in                       // no updates on nil
       (for i in (1 .. length(l))
          let l2 := (l[i] as restriction).domain in
            (if tmatch?(x.domain, l2)
                (if tmatch?(l2, x.domain)
                    (l[i] := x, l1 := l, break(true))
                 else (l1 := nth+(l, i, x), break(true)))
             else if (not(tmatch?(l2, x.domain)) & x.domain join l2)
                trace(2, ("~S and ~S are conflicting"), l[1], x)),
        if (length(l1) != 0) l1
        else add!(l, x)) ]

// definition of dictionary: standart hash-table
[hashinsert(m:restriction) : any
 -> // if (verbose() = 4) //[0] hashinsert(~S) // m,
    let c := (domain!(m) as class) in
       for c2 in c.descendents hashinsert(c2, (m as method)) ]

[hashinsert(c:class,x:method) : any
 -> if not(c.dictionary) c.dictionary := hashlist(29),
    // if (verbose() = 4) //[0] hashinsert(~S) into ~S // x,c,
    c.dictionary := hashinsert(c.dictionary, x) as list,
    c.dictionary ]

// v3.3.06: returns the new hash list when x is inserted (not necessarily the same list since l may grow)
hashinsert(l:list,x:method) : any
 -> let p := x.selector,
        i := hash(l, p),
        m := length(l) in
       (while true
         (if (l[i] = unknown | (l[i] as method).selector = p)
             (if (l[i] = unknown | domain!(x) inherit? domain!((l[i] as method)))
                 l[i] := x,
              break(l))
          else if (i = m)
             (if ((hashsize(l) * 3) > (length(l) * 2))
                 let myl2 := hashgrow(l, hashinsert) in
                   break(hashinsert(myl2, x))
              else i := 1)
          else i :+ 1))

[hashget(c:class,p:property) : object
 -> let l := c.dictionary,
         i := hash(l, p),
         m := length(l) in
       ((while true
         (if (l[i] = unknown) break(false)
          else if ((l[i] as method).selector = p) break(l[i])
          else if (i = m) i := 1
          else i :+ 1)) as object) ]

// look if two signature have a non-empty intersection
// note that the first case with classes is necessary for bootstraping
[join(x:list,y:list) : boolean
 -> let n := length(x) in
       (n = length(y) &
        forall(i in (1 .. n) |class!(x[i] as type) join class!(y[i] as type)) &
        forall(i in (1 .. n) | x[i] glb y[i])) ]

// *********************************************************************
// *      Part 3: Matching Methods                                     *
// *********************************************************************

// find the correct restrictions to be applied on a given set
// This is also optimized because it is very useful (it returns false if none is found)
[@(self:property,x:class) : object
 ->  if self.dictionary hashget(x, self)
     else let rx := some(r in self.definition |
                          (x inherit? class!(r.domain[1]))) in
       (if known?(rx) rx else false) ]


// finds a property through its full domain
[@(self:property,lt:list) : object
 ->  let rx := some(r in self.definition | tmatch?(lt, r.domain)) in
       (if known?(rx) rx else false) ]


// method's pattern matching
matching?(l:list,n:integer,m:integer) : boolean
 -> (let x := (m - n), z := length(l) in
       (if (z = x & l[x] != listargs)
           not((for i in (1 .. x)
                  let y := ((n - 1) + i),
                      u := l[i] in
                    (if (if (owner(u) = class)
                         not(owner(get_stack(y)) inherit? (u as class))
                      else not(vmatch?(u, get_stack(y), n))) break(true))))
        else if (last(l) = listargs & x >= z - 1)   // v3.2.24
           not((for i in (1 .. z)
                  let y := ((n - 1) + i) in
                    (if (l[i] = listargs)
                        (put_stack(y, get_args(y)),
                         set_index(y + 1),
                         break(false))
                     else if not(vmatch?(l[i], get_stack(y), n))
                        break(true))))
        else false))

// type's pattern matching
// v3.0.65: use %type for Param
[vmatch?(t:any,x:any,n:integer) : boolean
 -> case t
      (class owner(x) inherit? t,
       set contain?(t, x),
       subtype ((if (t.arg = subtype) x % type else x % t.arg) &
                 (x as type) <=t  t.t1),
       Param (vmatch?(t.arg, x, n) &
              forall(i in (1 .. length(t.params)) |
                      let %t := t.args[i], %v :=  funcall((t.params[i] as property),x) in
                         (if (%t % set) %type(%v,%t) else vmatch?(%t, %v, n)))),
       Reference let v := get(t, get_stack(n + t.index)) in
                   (if t.arg x = v else x % v),
       tuple case x
             (tuple (length(t) = length(x) &
                     forall( i in (1 .. length(x)) | vmatch?(t[i], x[i], n))),
              any false),
       any x % t) ]

// method's pattern matching based on types (i.e. l2 is another list
// of types).
tmatch?(l:list,l2:list) : boolean
 -> (let x := length(l2), z := length(l) in
       (if (length(l) != x & (l2[x] != listargs | z < x - 1)) false           // v3.2.24
        else not((for i in (1 .. x)
                    (if (i = x & l2[i] = listargs) break(false)
                     else if not(tmatch?(l[i], l2[i], l)) break(true))))))

// types pattern matching (t is the variable and t2 the pattern)
// note that less is redefinable
[tmatch?(t:any,t2:any,l:list) : boolean
 -> case t2
      (class case t (class t inherit? t2, any (t as type) <=t t2),
       subtype ((if (t2.arg = subtype) ((t as type) <=t type)
                 else tmatch?(t, t2.arg, l)) &
                tmatch?(member(t), t2.t1, l)),
       Param (tmatch?(t, t2.arg, l) &
              forall( i in (1 .. length(t2.params)) |
                      tmatch?((t as type) @ (t2.params[i] as property),
                                t2.args[i], l))),
       Reference (if t2.arg false
                  else (//[5] question is ~S less than ~S ? // t,t2,
                        (t as type) <=t @(t2, t2.args, l[t2.index + 1]))),  // how could we
       tuple case t
             (tuple (length(t2) = length(t) &
                     forall(i in (1 .. length(t2)) |
                            tmatch?(t[i], t2[i], l))),
              any false),
       any ((t as type) <=t (t2 as type)))  ]

// find the restriction
[find_which(p:property,n:integer,c:class) : object
 -> (if p.dictionary hashget(c, p) // v3.2.58  was ... (length(p.dictionary) != 0) hashget(c, p)
     else for r:restriction in p.definition
            (if matching?(r.domain, n, index!()) break(r))) as object]

[find_which(l:list,c:class,n:integer,m:integer) : object
 -> (for r:restriction in l (if matching?(r.domain, n, m) break(r))) as object]

// special version for super
[find_which(c:class,l:list,n:integer,m:integer) : object
 -> (for r:restriction in l
       (if (c <=t r.domain[1] & matching?(r.domain, n, m)) break(r))) as object]



//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| object.cl                                                   |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in about()                               |
//+-------------------------------------------------------------+

// ---------------------------------------------------------------------
// This file contains the definition of the objects that implement the
// core features of the microCLAIRE library: traceable & debug-able calls,
// tables, demons and exceptions
// ---------------------------------------------------------------------

// *********************************************************************
// *  Table of contents                                                *
// *   Part 1: Ask, debug & trace                                      *
// *   Part 2: Tables                                                  *
// *   Part 3: Demons & relations for the logic modules                *
// *   Part 4: Basics of Exceptions                                    *
// *********************************************************************


// release() should produce a version number
(system.version := Id(RELEASE),
 printf("-- CLAIRE run-time library v 3.~A [os: ~A, C++:~A ] --\n",
        Id(RELEASE),Id(compiler.env), Id(compiler.external)))

[release() : any -> ("3." /+ string!(system.version)) ]

// the about method produces the legal warning, according to the GNU software
// recommendation
about() : any
 -> (printf("CLAIRE v3.~A Copyright (C) 1994-2013 Yves Caseau. All Rights Reserved.\n",
            version()),
     printf("use and redistribution in source code or binary forms are permitted\n"),
     printf("resale is not permitted without the explicit agreement of Yves Caseau\n"),
     printf("THIS SOFTWARE IS PROVIDED AS IS AND WITHOUT ANY WARRANTY, INCLUDING,\n"),
     printf("WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILTY AND FITNESS\n"),
     printf("FOR A PARTICULAR PURPOSE\n"),
     true)

// *********************************************************************
// *   Part 1: Ask, debug & trace                                      *
// *********************************************************************

// create the list of arguments if needed : allocate on the stack
[get_args(i:integer) : list
 -> let liste := list<any>() in
       (while (i < index!()) (liste :add get_stack(i), i := i + 1), liste) ]

// evaluation of a message without the message structure, with a list
// of arguments. This method must be garbage-protected, because it is
// used as an entry point.
// to remove !!!!
;ask(self:any,p:property,arg:list) : any
; -> (let start := index!() in
;       (push!(self),
;        for x in arg push!(x),
;        eval_message(p, find_which(p, start, owner(self)), start, true)))

// a simple method for a direct call with no argument
funcall(self:method,x:any) : any
 -> (let start := index!() in
       (push!(x), execute(self, start, false)))

// this is a simple method for calling directly a method with one argument
funcall(self:method,x:any,y:any) : any
 -> (let start := index!() in
       (push!(x), push!(y), execute(self, start, false)))

// this is a simple method for calling directly a method with two arguments
funcall(self:method,x:any,y:any,z:any) : any
 -> (let start := index!() in
       (push!(x),
        push!(y),
        push!(z),
        execute(self, start, false)))

// how to apply a function to a list
apply(self:function,ls:list,l:list) : any
 -> (let start := index!() in
       (for x in l push!(x),
        stack_apply(self, ls, start, index!())))
call(p:property,l:listargs) : any -> apply(p, l)

apply(p:property,l:list) : any
 -> let start := index!() in
            (for x in l push!(x),
             eval_message(p, find_which(p, start, owner(l[1])), start,
                          true))

apply(m:method,l:list) : any
 -> (let start := index!() in
       (for x in l push!(x), execute(m, start, false)))


// push and pop debug info on the stack
// this method also does the tracing and the steppping
// NOTE: self should be either a property or a restriction
push_debug(prop:property,arity:integer,start:integer) : void
 -> (let i := index!(),
         n := system.trace! in
       (if (n > 0 &
            ((prop.trace! + system.verbose) > 4 | n = system.step!))
           let p := use_as_output(system.ctrace) in
             (put(trace!, system, 0),
              printf("~I ~S(~S", tr_indent(false, n), prop, get_stack(start)),
              let j := (start + 1) in
                while (j < (start + arity)) (printf(",~S", get_stack(j)), j :+ 1),
              if (prop.trace! >= 1000) system.step! := n,
              if (system.count_call >= 0)
                 (system.count_call :+ 1, printf(" [~A]",system.count_call),
                  if (system.count_call = system.count_level)
                     (if (system.count_trigger = call_step) system.step! := n
                      else if (system.count_trigger = spy) system.spy! := spy @ void
                      else system.verbose := system.count_trigger) ),
              if (n = system.step!) call_step(prop)
              else printf(")\n"),
              system.trace! := n + 1,
              use_as_output(p))
        else if (n > 0 & system.step! > 0)
           (if (system.count_call >= 0) system.count_call :+ 1, system.trace! := n + 1),
        if known?(StopProperty,prop)
           (if (StopProperty[prop] = nil |
                exists( l2 in StopProperty[prop] |
                        forall(j in (1 .. length(l2)) |(j + start <= i &
                                                 l2[j] = get_stack(start + j - 1)))))
                error("stop as required in ~S(~A)",prop,get_args(start))),
        push!(system.debug!),
        push!(prop),
        push!(arity),
        push!(start),
        put(debug!, system, i)))

// value of the previous debug
// n is 0 for interpreted code and 1 for compiled code
pop_debug(self:property,n:integer,val:any) : void
 -> (let v:integer := system.debug! in
       (if (v > 0)
           (if (n != 0) set_index(get_stack(v + 3) as integer),
            put(debug!, system, get_stack(system.debug!)),
            if (self.if_write = unknown) 
              let m := system.spy! in
                (if (m != unknown)                  // v3.3.14
                   (put(spy!, system, unknown),     // v3.0.3
                    funcall(m as method, system),
                    write(spy!, system, m))),
            if (system.trace! > 1 &
                ((self.trace! + system.verbose) > 4 | system.step! != 0))
               let i:integer := system.trace! in
                 (write(trace!, system, 0),
                  if ((self.trace! + system.verbose) > 4)
                     let p := use_as_output(system.ctrace) in
                       (printf("~I ~S\n", tr_indent(true, i - 1), val),
                        use_as_output(p)),
                  if (i <= system.step!) write(step!, system, i - 1),
                  write(trace!, system, i - 1),
                  if (system.trace! = 1) write(step!, system, 0)))))

// print a nice indented mark
tr_indent(return?:boolean,n:integer) : void
 -> (if return? printf("[~A]", n)
     else printf("~A:=", n),
     while (n > 9) (princ("="), n := n - 10),
     while (n > 0) (princ(">"), n := n - 1))

// *********************************************************************
// *   Part 2: Tables                                                  *
// *********************************************************************

// finds if objects are identified
identified?(self:class) : boolean
 -> (self = integer | self inherit? object | self = symbol | self = boolean |
     self = char)

identical?(x:any,y:any) : boolean
  ->  externC("((x == y) ? CTRUE : CFALSE)",boolean)

//  let x1: (if ((x as boolean) = (y as boolean)) true else false)

// writing a single value into a slot but does NOT trigger the rules !
// equivalent to is! of LAURE
// this definition should not be placed in the method.cl file
// (it requires some inheritance conflict processing)
put(self:property,x:object,y:any) : any
 -> (let s := (self @ owner(x)) in
       case s
        (slot store(x, s.index, s.srange, y, self.store?),
         any selector_error(selector = self, arg = list(x))))

         
// v3.2 : same but multi valued
[add_value(self:property,x:object,y:any) : void
  -> let s := (self @ owner(x)) in
    (if not(s) selector_error(selector = self, arg = list(x))
     else if not(multi?(self)) error("[134] Cannot apply add to ~S", self)
     else let n := (s as slot).index,
              l1 := (slot_get(x, n, object) as bag) in
            add_value(self, x, n, l1, y)) ]

         
// access
nth(a:table,x:any) : type[(if unique?(a) the(a).range else any)]
 -> let p := a.params in
       (if not(x % a.domain)
           error("[135] ~S does not belong to the domain of ~S", x, a),
        let v := (case p
                  (integer a.graph[(x as integer) - p],
                   list a.graph[get_index(a, (x as list)[1], (x as list)[2])],
                   any let i := index(a, x) in a.graph[i])) in
          (if (known?(v) | v % a.range) v
           else error("[138] the value ~S(~S) is unknown !",a,x)))

get(a:table,x:any) : type[(if unique?(a) (the(a).range U {unknown}) else any)]
 -> (let p := a.params in
       (if not(x % a.domain) unknown
        else let i := get_index(a, x) in a.graph[i]))

// interface update method for a[x] := y
nth=(a:table,x:any,y:any) : void
 -> (if not(x % a.domain)
        error("[135] ~S does not belong to the domain of ~S", x, a),
     if not(y % a.range) range_error(cause = a, arg = y, wrong = a.range),
     nth_put(a, x, y)) 

// internal form without checks
// equivalent of update = put + put_inverse
nth_put(a:table,x:any,y:any) : void
 -> (if  (known?(if_write,a) & not(multi?(a))) fastcall(a,x,y)
     else if multi?(a)
        let r := get(inverse, a),
            old := get(a,x) in  // v3.3.38 : redo (thanks to <sb>)
          (a.graph[get_index(a, x)] :=
             (if (length((y as set)) = 0) y    // we install a new value -> direct write 
              else if (a.multivalued? = list) 
                    make_list(0,of_extract(a.range),0)  // watch out: a.default does not always exist
              else cast!(set(),of_extract(a.range))),   // of_extract is a fast member(..)
           if (old != unknown & known?(r)) for z in old update-(r, z, x),
           for z in (y as set) add!(a, x, z))
     else let  r := get(inverse, a), z := get(a,x) in
             (if (z != y)
                 (if known?(r)
                   let z := get(a,x) in
                      (if (known?(z) & (r != a | x != z)) update-(r, z, x)),
                       put(a, x, y),
                       update+(a, x, y))))

// put does NOT update the inverse
put(a:table,x:any,y:any) : void
 -> let p := a.params, z := get(a,x)  in
       (if (z != y)
           (case p
             (integer store(a.graph, x - p, y, a.store?),
              list store(a.graph,
                         get_index(a, (x as list)[1], (x as list)[2]), y,
                         a.store?),
              any let i := index(a, x) in store(a.graph, i, y, a.store?)),
            true))

// adds a value to a multi-valued table: interface method
add(a:table,x:any,y:any) : void
 -> (if not(x % a.domain)
        error("[135] ~S does not belong to the domain of ~S", x, a),
     if not(y % member(a.range)) range_error(cause = a, arg = y, wrong = a.range),
     add!(a, x, y))

// adds a value to a multi-valued table: internal version without type checks
add!(a:table,x:any,y:any) : void
 -> (if known?(if_write,a) fastcall(a,x,y)
     else let p := a.params,
         i := get_index(a, x),
         l := (a.graph[i] as bag) in
       (if add_value(a, i, l, y) update+(a, x, y)))

// this methods adds a value to a multi-slot (used by the compiler)
add_value(self:table,n:integer,l:bag,y:any) : boolean
 -> (if (self.multivalued? = true)
        (if not(y % l)
            let l1 := (add!@set((if self.store? copy(l) else l), y)) in
              (store(self.graph, n, l1, self.store?), true)
         else false)
     else let l1 := (if self.store? store(l, y) else add!@list(l, y)) in
            (store(self.graph, n, l1, self.store?), true))

// a direct version (v3.2) that can be used in lieu of add!
add_value(self:table,x:any,y:any) : void
 -> (let p := self.params,
         i := get_index(self, x),
         l := (self.graph[i] as bag) in
       add_value(self, i, l, y))
            
// removes a value from an table
delete(a:table,x:any,y:any) : any
 -> (let p := a.params,
         i := get_index(a, x),
         l1 := (a.graph[i] as set),
         l := ((if a.store? copy(l1) else l1) delete y) in
       (store(a.graph, i, l, a.store?),
        let r := a.inverse in (if known?(r) update-(r, y, x)),
        l))

// direct access to 2-dim tables
[nth(a:table,x:any,y:any) : type[(if unique?(a) the(a).range else any)]
 -> let p := a.params,
        v := (case p
                (list (if not((x % (a.domain as tuple)[1] &
                               y % (a.domain as tuple)[2]))
                         error("[135] ~S does not belong to the domain of ~S", x, a),
                       a.graph[get_index(a, x, y)]),
                 any index(a, x, y)))  in
         (if (known?(v) | v % a.range) v else error("~S(~S) is unknown !",a,x))]

// sets a value in a 2-dim table
nth=(a:table,x:any,y:any,z:any) : void
 -> let p := a.params in
      (case p
        (list (if not((x % (a.domain as tuple)[1] &
                       y % (a.domain as tuple)[2]))
                  error("[135] ~S does not belong to the domain of ~S", list(x,y), a),
               if not(z % a.range)
                  range_error(cause = a, arg = z, wrong = a.range),
               if (known?(inverse, a) | known?(if_write, a))
                  nth_put(a, list(x, y), z)
               else store(a.graph, get_index(a, x, y), z, a.store?)),
         any nth=(a, tuple(x, y), z)))          // v3.2.16 tuple(a,b) is not list(a,b) !

get_index(a:table,x:any) : integer
 -> (let p := a.params in
       case p
        (integer (x as integer) - p,
         list get_index(a, (x as list)[1], (x as list)[2]),
         any index(a, x)))

get_index(a:table,x:integer,y:integer) : integer
 -> let p := (a.params as list<integer>) in (((p[1] * x) + y) - p[2])


// erase an table means to clean its graph so that it becomes empty.
erase(a:table)  : void
  -> let p := a.params in
       (case p
         (integer (for i in domain(a) a.graph[get_index(a,i)] := a.default),
          list (for l:list in domain(a) a.graph[get_index(a,l[1],l[2])] := a.default),
          any (for i in (1 .. length(a.graph))
                  (a.graph as list)[i] := unknown)))

// new in v3.2.50 a constructor for building a table dynamically
claire/make_table(%domain:type, %range:type, %default:any) : table
  -> let t := (mClaire/new!(table) as table) in   
       (t.range := %range, 
        table.instances :add t,                          // v3.3.3
        t.domain := %domain,
        t.default := %default,
        t.params := any,
        t.mClaire/graph := make_list(29,unknown),
        t)


// Our first table: a debuging tool which stores a list of stopping values
StopProperty[p:property] : list := unknown

// *********************************************************************
//   Part 3: Demons & relations for the logic modules                  *
// *********************************************************************

// applying a lambda to one argument
funcall(self:lambda,x:any) : any
 -> (let start := mClaire/index!(),
         retour := mClaire/base!() in
       (mClaire/set_base(start),
        mClaire/push!(x),
        mClaire/stack_apply(self.dimension),
        let val := eval(self.body) in
          (mClaire/set_base(retour), mClaire/set_index(start), val)))

// applying a lambda to two argument
[funcall(self:lambda,x:any,y:any) : any
 ->  let start := mClaire/index!(),
         retour := mClaire/base!() in
       (mClaire/set_base(start),
        mClaire/push!(x),
        mClaire/push!(y),
        mClaire/stack_apply(self.dimension),
        let val := eval(self.body) in
          (mClaire/set_base(retour),
           mClaire/set_index(start),
           val)) ]

// applying a lambda to two argument
[funcall(self:lambda,x:any,y:any,z:any) : any
 ->  let start := mClaire/index!(),
         retour := mClaire/base!() in
       (mClaire/set_base(start),
        mClaire/push!(x),
        mClaire/push!(y),
        mClaire/push!(z),
        mClaire/stack_apply(self.dimension),
        let val := eval(self.body) in
          (mClaire/set_base(retour),
           mClaire/set_index(start),
           val)) ]


// for historical reasons
mClaire/pname :: property()

// dealing with inverse
check_inverse(%r1:any,%r2:any) : void
 -> (let r1 := (%r1 as relation),
         r2 := (%r2 as relation) in
       (put(inverse,r1,r2),
        put(inverse,r2,r1),
        final(r1),
        final(r2),
        if (not(r1.domain <=  (if multi?(r2) member(r2.range) else r2.range)) |
            not(r2.domain <=  (if multi?(r1) member(r1.range) else r1.range)))
           error("[137] ~S and ~S cannot be inverses for one another", r1, r2)))

(relation.open := 0,
 write(inverse, inverse, inverse),
 write(if_write, inverse, (check_inverse @ any).functional))


// very useful
invert(r:relation,x:any) : bag
 -> (let r2 := get(inverse, r) in
       case r2
        (table let v := r2[x] in (if (r2.multivalued? != false) (v as bag) else set(v)),
         property let v := get(r2, x) in
                    (if (r2.multivalued? != false) (v as bag) else set(v)),
         any case r
             (property (if (r.multivalued? != false) { z in r.domain | x % get(r, z)}
                       else { z in r.domain | get(r, z) = x}),
              table (if (r.multivalued? != false) { z in r.domain | x % r[z]}
                     else { z in r.domain | r[z] = x}))))

// same: two useful methods that are used often
domain!(x:restriction) : class -> class!(x.domain[1])
methods(d:class,r:class) : set
 -> { m in method | (m.domain[1] <= d & m.range <= r)}

// sets the reified flag
claire/reify  :: property()
reify(l:listargs) : void
  -> (for p in l
       (case p (property p.reified := true)))

// *********************************************************************
// *   Part 4: Basics of Exceptions                                    *
// *********************************************************************

**arg :: property(open = 0)
args :: property(open = 0)
value :: property()

// a generic error that is produced by the error(" ....") instruction
general_error <: error(cause:any,arg:any)
self_print(self:general_error) : void
 -> printf("**** An error has occurred.\n~I\n", format(self.cause, self.arg))

// a read_slot error is produced when an unknown value is found
read_slot_error <: error(arg:any,wrong:any)
self_print(self:read_slot_error) : void
    -> printf("****[138] The value of ~S(~S) is unknown", self.wrong, self.arg)

// range errors
range_error <: error(cause:any,arg:any,wrong:any)
self_print(self:range_error) : void
    -> printf("****[139] ~S: range error, ~S does not belong? to ~S.\n",
              self.cause, self.arg, self.wrong)

// selector errors
selector_error <: error(selector:any,arg:any)
self_print(self:selector_error) : void
  -> (let p := self.selector in
        (if not(p.restrictions)
          printf("[140] The property ~S is not defined (was applied to ~S).\n", p, self.arg)
         else printf("****[141] ~S is a wrong arg list for ~S.\n",self.arg, p)))

// produced by a return (usually trapped)
return_error <: error(arg:any)
self_print(self:return_error) : void
  -> printf("****[142] return called outside of a loop (for or while).")

// interpretation of all the error codes
self_print(self:system_error) : void
 -> (let n := self.index in
       (printf("**** An internal error [~A] has occured:\n", n),
        format((if (n = 1) "dynamic allocation, item is too big (~S)"
                else if (n = 2) "dynamic allocation, too large for available memory (~S)"
                else if (n = 3) "object allocation, too large for available memory (~S)"
                else if (n = 5) "nth[~S] outside of scope for ~S"
                else if (n = 7) "Skip applied on ~S with a negative argument ~S"
                else if (n = 8) "List operation: cdr(()) is undefined"
                else if (n = 9) "String buffer is full: ~S"
                else if (n = 10) "Cannot create an imported entity from NULL reference"
                else if (n = 11) "nth_string[~S]: string too short~S"
                else if (n = 12) "Symbol Table table full"
                else if (n = 13) "Cannot create a subclass for ~S [~A]"
                else if (n = 16) "Temporary output string buffer too small"
                else if (n = 17) "Bag Type Error: ~S cannot be added to ~S"
                else if (n = 18) "definition of ~S is in conflict with an object from ~S"
                else if (n = 19) "Integer overflow"
                else if (n = 20) "Integer arithmetic: division/modulo of ~A by 0"
                else if (n = 21) "Integer to character: ~S is a wrong value"
                else if (n = 22) "Cannote create a string with negative length ~S"
                else if (n = 23) "Not enough memory to instal claire"
                else if (n = 24) "execution stack is full [~A]"
                else if (n = 26) "Wrong usage of time counter [~A]"
                else if (n = 27) "internal garbage protection stack overflow"
                else if (n = 28) "the multivalued status of ~S is not compatible with ~S"
                else if (n = 29) "There is no module ~S"
                else if (n = 30) "Attempt to read a private symbol ~S"
                else if (n = 31) "External function not compiled yet"
                else if (n = 32) "Too many arguments (~S) for function ~S"
                else if (n = 33) "Exception handling: stack overflow"
                else if (n = 34) "User interrupt: EXECUTION ABORTED"
                else if (n = 35) "reading char '~S': wrong char: ~S"
                else if (n = 36) "cannot open file ~A"
                else if (n = 37) "world stack is full"
                else if (n = 38) "Undefined access to ~S"
                else if (n = 39) "cannot convert ~S to an integer"
                else if (n = 40) "integer multiplication overflow with ~S and ~S"
                else if (n = 41) "wrong NTH access on ~S and ~S"
                else if (n = 42) "Wrong array[~S] init value: ~S"
                else if (n = 43) "Defeasible addition on list ~S requires pre-allocation (size ~S)" // v3.3.06
                else if (n = 50) "C++ imported error (~S) : ~S"   // NEW IN v3.1.04 (backdoor)
                else (self.value := n,
                      "What the hell is this ! [code: ~S^]")),
               list(self.value, self.arg))))

// contradictions are nice exceptions
contradiction <: exception()
self_print(x:contradiction) : void
 -> printf("A contradiction has occured.")

// the format method is used to print error messages (similar to a printf)
[format(self:string,larg:list) : void
 ->  let s := self,
         n := get(s, '~'),
         l := copy(larg) in
       (while not(n = 0)
          let m := s[n + 1] in
            (if (n > 1) princ(substring(s, 1, n - 1)),
             if ('A' = m) princ(car(l))
             else if ('S' = m) print(car(l))
             else if ('I' = m) error("[143] ~I not allowed in format", unknown),
             if (m != '%') l := l << 1,
             s := substring(s, n + 2, 1000),
             n := get(s, '~')),
        if (length(s) > 0) princ(s)) ]

// special version that prints in the trace port
tformat(self:string,i:integer,l:list) : any
 -> (if (i <= system.verbose)
        let p := use_as_output(system.ctrace) in
          (format(self, l), use_as_output(p)))

// printing a bag without ( )
princ(s:bag) : void
 -> (let f := true in
       for x in s (if f f := false else princ(","), print(x)))

// a global variable is a named object with a special evaluation
// NOTE: we need to refine the scheme for global constants !
global_variable <: system_thing(
    value:any,                    // the value
    range:type = any,             // the range is a type, {} means a global constant
    store?:boolean = false)       // GV are defeasible

close(self:global_variable) : global_variable
 -> (if not((unknown?(value, self) |
             (self.range % set | self.value % self.range)))
        range_error(arg = self.value, cause = self, wrong = self.range),
     self)

<=2 :: operation()

// we create a spcial contraidiction that we shall reuse
contradiction_occurs :: global_variable(range = contradiction,
                                        value = new!(contradiction))

// how to use it
contradiction!(system) : void -> close(contradiction_occurs)
nil :: global_variable(range = {}, value = Id(nil))       // v0.01
claire_date:string :: Id(date!(1))


// end of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| pretty.cl                                                   |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// *********************************************************************
// *  Contents:                                                        *
// *  Part 1: unbound_symbol and variables                             *
// *  Part 2: lambdas                                                  *
// *  Part 3: close methods for lattice_set instantiation              *
// *  Part 4: Pretty printing                                          *
// *********************************************************************

Instruction <: system_object()
Basic_instruction <: Instruction()

no_eval(self:Instruction) : any
 -> error("[144] evaluate(~S) is not defined", owner(self))

// import
iClaire/typing :: Kernel/typing
iClaire/index :: mClaire/index

// *********************************************************************
// *   Part 1: unbound_symbol and variables                            *
// *********************************************************************

// An unbound_symbol is created by the reader when a symbol is not bound
//
//unbound_symbol <: Basic_instruction(identifier:symbol)
self_print(self:unbound_symbol) : void
   -> printf("~A", self.name)
self_eval(self:unbound_symbol) : any
   -> (if (get(self.name) % thing)  eval(get(self.name))
       else error("[145] the symbol ~A is unbound",  self.name))

// A lexical variable is defined by a "Let" or inside a method's definition
//
// Lexical variables --------------------------------------------------
//
Variable[mClaire/pname,range] <: Basic_instruction(
     mClaire/pname:symbol,              // name of the variable
     range:type,                        //
     index:integer)                     // position in the stack

self_print(self:Variable) : void ->
  (when s := get(mClaire/pname,self) in princ(s) else princ("V?"))

ppvariable(self:Variable) : void
 -> (if known?(range, self)
        printf("~A:~I", self.mClaire/pname, printexp(self.range, false))
     else princ(self.mClaire/pname))

ppvariable(self:list) : void
 -> (let f := true in
       for v in self
         (if f f := false
          else princ(","),
          case v (Variable ppvariable(v), any print(v))))

self_eval(self:Variable) : any -> mClaire/get_stack(mClaire/base!() + self.index)

write_value(self:Variable,val:any) : any
 -> (if (unknown?(range, self) | val % self.range)
        mClaire/put_stack(mClaire/base!() + self.index, val)
     else range_error(arg = self, cause = val, wrong = self.range))

// this is the definition of a typed variable
//
Vardef <: Variable()
self_eval(self:Vardef) : any
  ->  (when i := get(index,self) in mClaire/get_stack(mClaire/base!() + i)
       else error("[146] The variable ~S is not defined",self))

//   [self_print(self:Vardef) : any -> ppvariable(self) ]
Complex_instruction <: Instruction()
Instruction_with_var <: Complex_instruction(var:Variable)
Control_structure <: Complex_instruction()

// global_variables are defined in exception ? ---------------------------
// a global variable is a named object with a special evaluation
//
self_eval(self:global_variable) : any -> self.value
write_value(self:global_variable,val:any) : any
 -> (if (val % self.range)
        (put_store(value,self,val,self.store?), val)
     else range_error(cause = self, arg = val, wrong = self.range)) // v0.01

(put(mClaire/evaluate, global_variable, function!(self_eval_global_variable)),
 put(mClaire/evaluate, unbound_symbol, function!(self_eval_unbound_symbol)))

// same as C
EOF :: global_variable(range = char, value = char!(externC("((int) EOF)",integer))) // v3.2.52
EOS :: global_variable(range = char, value = char!(0))

// v3.4
claire/MAX_INTEGER :: 1073741822

// *********************************************************************
// *   Part 2: CLAIRE Lambdas                                           *
// *********************************************************************

// CLAIRE lambdas are the basic functional objects, defined by a filter
// and a piece of code. Lambda is defined in the "method" file.
// applying a lambda to a list of arguments
//
apply(self:lambda,%l:list) : any
 -> (let start := mClaire/index!(),
         retour := mClaire/base!() in
       (mClaire/set_base(start),
        for %x in %l mClaire/push!(%x),
        mClaire/stack_apply(self.dimension),
        let val := eval(self.body) in
          (mClaire/set_base(retour), mClaire/set_index(start), val)))
call(self:lambda,l:listargs) : any -> apply(self, l)

// printing a lambda
//
self_print(self:lambda) : any
 -> printf("lambda[(~I),~I~S~I]", ppvariable(self.vars), lbreak(1),
           self.body, (pretty.index :- 1))

// lambda! and flexical_build communicate via a global_variable, which
// however is only used in this file (and also by cfile :-) ):
//
*variable_index* :: global_variable(range = integer, value = 0)

// creating a lambda from an instruction and a list of variables
lambda!(lvar:list,self:any) : lambda
 -> (*variable_index* := 0,
     for v:Variable in lvar
       (put(index, v, *variable_index*),
        put(isa, v, Variable),
        *variable_index* :+ 1),
     let corps := lexical_build(self, lvar, *variable_index*),
         resultat:lambda := mClaire/new!(lambda) in
       (put(vars, resultat, lvar),
        put(body, resultat, corps),
        put(dimension, resultat, *variable_index*),
        resultat))

// Give to each lexical variable its right position in the stack.
// We look for a named object or an unbound symbol to replace by a lexical
// variable.
// The number of variables is kept in the global_variable *variable_index*.
// On entry, n need not be equal to size(lvar) (see [case ...instruction]).
//
lexical_build(self:any,lvar:list,n:integer) : any
 -> (if (self % thing | self % unbound_symbol) lexical_change(self, lvar)
     else (case self
            (Variable (if unknown?(index,self)                          // v3.1.12
                          error("[145] the symbol ~A is unbound",  self.mClaire/pname),
                       self),
             Call let s := lexical_change(self.selector, lvar) in
                    (lexical_build(self.args, lvar, n),
                     if (self.selector != s)
                        (put(selector, self, call),
                         put(args, self, s cons self.args))),
             Instruction let %type:class := self.isa in
                           (if (%type % Instruction_with_var.descendents)
                               (put(index, self.var, n),
                                n := n + 1,
                                if (n > *variable_index*)
                                   *variable_index* := n),
                            for s in %type.slots
                              let x := get(s, self) in
                                (if ((x % thing | x % unbound_symbol) &
                                     s.range = any)
                                    put(s, self, lexical_change(x, lvar))
                                 else lexical_build(x, lvar, n))),
             bag let %n := length(self) in
                   while (%n > 0)
                     (let x := (nth@list(self, %n)) in
                        (if (x % thing | x % unbound_symbol)
                            nth=@list(self, %n, lexical_change(x, lvar))
                         else lexical_build(x, lvar, n)),
                      %n :- 1),
             any nil),
           self))

lexical_change(self:any,lvar:list) : any
 -> (let rep:any := self,
         %name:symbol := (case self  (Variable self.mClaire/pname,
                                      any extract_symbol(self))) in
       (for x:Variable in lvar (if (x.mClaire/pname = %name) rep := x), rep))

// *******************************************************************
// *       Part 3: functions for lattice_set instantiation           *
// *******************************************************************
// close is the basic method called by an instantiation.
// Once the indexed list is built, we never call it again.
//
close(self:class) : class -> self

// Extract the symbol associated with self.
// This is useful e.g. when using read() (read@port, read@string).
//
extract_symbol(self:any) : symbol
 -> (case self
      (unbound_symbol self.name,
       thing self.name,
       class self.name,
       symbol self,
       Variable self.mClaire/pname,
       boolean (if self symbol!("true") else symbol!("nil")),
       any error("[147] a name cannot be made from ~S", self)))

// we must be sure that the selector (in a has statement or in a message)
// is a property.
//
make_a_property(self:any) : property
 -> (case self
      (global_variable make_a_property(value(self)),
       property self,
       symbol let x := get(self) in
               (case x (property make_a_property(x),
                        global_variable  make_a_property(value(x)),
                        any  let p := (mClaire/new!(property, self) as property) in
                                 (p.comment := string!(self),
                                  put(domain, p, any),
                                  put(range, p, any),
                                  p))),
       unbound_symbol make_a_property(self.name),
       any error("[148] Wrong selector: ~S, cannot make a property\n", self)))

printl :: property()

// *********************************************************************
// *  Part 4: Pretty printing                                          *
// *********************************************************************

// fuck
lbreak() : any
 -> (if pretty.mClaire/pprint
        (if (pretty.mClaire/pbreak)
            (princ("\n"),
             put_buffer(),
             indent(pretty.index))
         else if (mClaire/buffer_length() > pretty.mClaire/width)  much_too_far()))

put_buffer() : any
 -> (let buffer := end_of_string() in
       (princ(buffer), print_in_string(), {}))

checkfar() : any
 -> (if (pretty.mClaire/pprint & not(pretty.mClaire/pbreak) &
         mClaire/buffer_length() > pretty.mClaire/width) much_too_far())

lbreak(n:integer) : any -> (pretty.index :+ n, lbreak())

// indentation
//
indent(limit:integer) : any
 -> (let x := mClaire/buffer_length() in while (x < limit) (princ(" "), x :+ 1))

// sets the current_level
set_level() : void
 -> (pretty.index := mClaire/buffer_length() - 1)
set_level(n:integer) : void -> (set_level(), pretty.index :+ n)

// prints a bag as a box
//
printbox(self:bag,start:integer,finish:integer,s:string) : any
 -> (let i := 1,
         startline := true,
         n := length(self),
         %l := pretty.index in
       (pretty.index := start,
        if (not(pretty.mClaire/pprint) | (not(short_enough(start + 10))
             & pretty.mClaire/pbreak))
           printl(self, s)
        else if not(pretty.mClaire/pbreak) printl(self, s)
        else while (i <= n)
               (while (Core/buffer_length() < start) printf(" "),
                let idx := Core/buffer_length() in
                  (try (pretty.mClaire/pbreak := false,
                        printexp(self[i], true),
                        pretty.mClaire/pbreak := true)
                   catch much_too_far (pretty.mClaire/pbreak := true,
                                       pretty.index := start),
                 if (i != n) princ(s),
                 if (Core/buffer_length() < finish)
                    (i :+ 1, startline := false)
                 else (Core/buffer_set_length(idx),
                       if not(startline) (lbreak(), startline := true)
                       else (set_level(),
                             pretty.index :+ 1,
                             printexp(self[i], true),
                             pretty.index := %l,
                             if (i != n) (princ(s), lbreak()),
                             i :+ 1)))),
        pretty.index := %l,
        unknown))

// default value of arguments
//
printbox(self:bag) : any
 -> printbox(self, mClaire/buffer_length(), pretty.mClaire/width, ", ")
printbox(self:bag,s:string) : any
 -> printbox(self, mClaire/buffer_length(), pretty.mClaire/width, s)
printl(self:bag,s:string) : void
 -> (let f := true,
         b := pretty.mClaire/pprint in
       (pretty.mClaire/pprint := false,
        try for x in self
          (if f f := false
           else princ(s),
           printexp(x, true),
           if (b & not(pretty.mClaire/pbreak) &
                   mClaire/buffer_length() > pretty.mClaire/width)
              (pretty.mClaire/pprint := b, much_too_far()))
        catch system_error let x := (system.exception! as exception) in
                             (if (b & x.index = 16)
                                 (pretty.mClaire/pprint := b, much_too_far())
                              else close(x)),
      pretty.mClaire/pprint := b))

// print bounded prints a bounded expression using ( and )
[printexp(self:any,comp:boolean) : void
 ->  if ((case self
           (Call not((self.selector % operation & not(comp) &
                      length(self.args) = 2)))) |
         self % Collect | self % Select | self % Definition |
         self % Construct | self % Do | self = unknown | self % And |
         self % import | self % Or | self % If | self % restriction |
         self % unbound_symbol | self % Variable | not(self % Instruction)) print(self)
     else let %l := pretty.index in
            (printf("(~I~S)", set_level(1), self), pretty.index := %l) ]

pretty_print(self:any) : void
 -> (print_in_string(),
     pretty.mClaire/pprint := true,
     pretty.mClaire/pbreak := true,
     pretty.index := 0,
     print(self),
     pretty.mClaire/pprint := false,
     princ(end_of_string()))

[self_print(self:list) : void
 -> if (of(self) != {}) printf("list<~S>",of(self)),
    printf("(~I)", printbox(self)) ]

[self_print(self:set) : void
  -> if (of(self) = {}) printf("{~I}", printbox(self))
     else  (printf("set<~S>",of(self)),
            printf("(~I)", printbox(self))) ]  

// to remove !
[self_print(self:tuple) : void
 -> printf("tuple(~I)", printbox(self)) ]


// bend of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| reader.cl                                                   |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// ---------------------------------------------------------------------
// this file contains the reader object and the top-level read functions
// the second part of the reader is in syntax.cl
// ---------------------------------------------------------------------

// **********************************************************************
// *  Content:                                                          *
// *   Part 1: The reader object                                        *
// *   Part 2: reading blocks                                           *
// *   Part 3: reading expressions                                      *
// *   Part 4: miscellaneous                                            *
// **********************************************************************

// **********************************************************************
// *   Part 1: The reader object                                        *
// **********************************************************************

// global definitions
delimiter <: global_variable()

arrow:any :: keyword(name = symbol!("->"))
(put(name(arrow), arrow))

triangle:any :: (keyword(name = symbol!("<:")))
// *arrow*:boolean :: false

// here we define the basic keywords
reserved_keyword <: keyword()

else :: reserved_keyword()
for :: reserved_keyword()
case :: reserved_keyword()
while :: reserved_keyword()
until :: reserved_keyword()
let :: reserved_keyword()
when :: reserved_keyword()
try :: reserved_keyword()
if :: reserved_keyword()
Zif :: reserved_keyword()
branch :: reserved_keyword()

keyword?(x:any) : boolean -> (x % reserved_keyword)

forall :: keyword()
none :: keyword()
None :: keyword()
:= :: keyword()
: :: keyword()
catch :: keyword()
in :: keyword()
as :: keyword()
:: :: keyword()
printf :: keyword()
assert :: keyword()
return :: keyword()
break :: keyword()
trace :: keyword()
exists :: keyword()
some :: keyword()
=> :: keyword()
? :: keyword()
rule :: keyword()
quote :: keyword()
claire/inspect :: property()
claire/known! :: property()


// the meta_class of the reader --------------------------------------
// The key values are placed in indexed so that they can be changed (eof ...).
// The slot *internal* is used to give addresses to lexical variables.
// The function next reads a character and places it in the slot first.
//
meta_reader <: thing(source:string,
                     s_index:integer = 0,
                     fromp:port,
                     nb_line:integer,
                     external:string = "toplevel",
                     index:integer,
                     last_form:any,              // v3.3: replaces LastExpRead
                     maxstack:integer,
                     toplevel:boolean,
                     eof:integer, space:integer, tab:integer, bracket:any,
                     paren:any, comma:any, curly:any,
                     last_arrow:boolean = false,     // v3.3
                     s_properties:set[property] = Id(reader.s_properties))


// **********************************************************************
// *   Part 2: reading blocks                                           *
// **********************************************************************

// closing brace as a CLAIRE entity
next(r:meta_reader) : integer -> externC("((int) r->fromp->getNext())",integer)
firstc(r:meta_reader) : integer -> externC("r->fromp->firstc",integer)


stop?(n:integer) : any -> (n = #/, | n = #/) | n = #/] | n = #/}) 

AND:any :: &
OR:any :: mClaire/new!(delimiter, symbol!("|", claire))

// sugar in file
;Declarations:set[property] :: Id(Declarations)

// this is used to keep comments when translating CLAIRE to another language
;LastExpRead:any := unknown                     // used to attach comments to exps

// read the next unit (definition, block or expression)
//
nextunit(r:meta_reader) : any
 -> let n := skipc(r) in
      (if (n = eof(r)) (next(r), eof)
       else if (n = #/[) let z := nexte(cnext(r)) in nextdefinition(r,z,nexte(r),true)
       else if (n = #/() (if toplevel(r) nexts(r, none)
                          else readblock(r, nexte(cnext(r)), #/)))
       else if (n = #/`) Quote(arg = nextunit(cnext(r)))
       else if (n = #/;)
          (while (firstc(r) != eof(r) & firstc(r) != 10) next(r),
           if (firstc(r) = eof(r)) eof
           else (nb_line(r) :+ 1, next(r), nextunit(r)))
       else let x := (if toplevel(r) nexts(r, none) else nextexp(r,true)) in
           (if (toplevel(r) & (case x (Assign (var(x) % Vardef))))
               Defobj(ident = mClaire/pname(var(x)), arg = global_variable,
                      args = list(Call(=, list(range, 
                                               extract_type(range(var(x))))),
                                  Call(=, list(value, arg(x)))))
            else if (x % string) x
            else if (case x (Call (x.selector % r.s_properties &               // v3.3
                                   forall(y in x.args | not(y % Vardef)))))
              let z := (x as Call), a := z.args[1] in
                 (if (z.selector = begin & a % unbound_symbol) z.args[1] := string!(extract_symbol(a)),
                  if (z.selector = end & a % module)  z.args[1] := claire,
                  x)
            else if not(toplevel(r) | x % Assert) nextdefinition(r,x,nexte(r),false)
            else x))


// read the next statement & stops at the keyword e or at a delimiter
// the keyword has been read but not the delimiter, so we know which case
// by testing stop?(first(r))
// Note: it actually reads a fragment
//
nexts(r:meta_reader, e:keyword) : any
 -> let n := skipc(r) in
      (if (n = eof(r)) (next(r), eof)
       else if (n = #/[) let z := nexte(cnext(r)) in nextdefinition(r,z,nexte(r),true)
       else if (e = None) nexte(r)
       else let x := nexte(r) in
              (if keyword?(x) nextstruct(r, x, e)
               else if (e = none & (case x (Call (x.selector % r.s_properties)))) x
               else loopexp(r, x, e, false)))

// loops until the right expression is built (ends with e ',', '}' or ')')
//
loopexp(r:meta_reader, x:any, e:keyword, loop:boolean) : any
 -> (if (toplevel(r) & e = none & findeol(r)) x
    else if (x = ?) Call(inspect, list(nexte(r)))
    else if (skipc(r) = #/:)
       let y := nexte(cnext(r)) in
         (if (y = =) loopexp(r, combine(x, :=, nexte(r)), e, true)
     //     else if (toplevel(r) & y = :) nextinst(r, x)
          else if (y = :) nextinst(r, x)    // AHA (v3.0.05)
          else if operation?(y) extended_operator(y,x,loopexp(r, nexte(r), e, false)) // v3.3.32
          else if (x % Call)
             let w := nexte(r) in
               (if (w = =>) r.last_arrow := true                  // v3.3.00
                else if not(w = arrow | w = :=) 
                  Serror("[149] wrong keyword (~S) after ~S",list(w,y)),
                nextmethod(r,x,y,(w = :=),false,(w = =>)))
          else Serror("[150] Illegal use of :~S after ~S", list(y, x)))
    else let y := nexte(r) in
           (if (y = e | (y = => & e = arrow))
               (if (y != e) r.last_arrow := true,                   // v3.3
                if stop?(firstc(r))
                   Serror("[151] ~S not allowed after ~S\n",
                          list(char!(firstc(r)), e))
                else x)
            else if (y = triangle | y = arrow | y = : | y = :: | y = =>)
                nextdefinition(r,x,y,false)
            else if (y % delimiter & stop?(firstc(r))) x
            else if operation?(y)
               (if loop loopexp(r, combine(x, y, nexte(r)), e, true)
                else loopexp(r, combine!(x, y, nexte(r)), e, true))
            else Serror("[152] Separation missing between ~S \nand ~S [~S?]",
                        list(x, y, e))))

// this is the special form for x :op y - new in v3.3.32
extended_operator(p:property,x:any,y:any) : any
  -> (case x (Call let r := (if (x.selector = nth) x.args[2] else x.args[1]),
                       v := Variable(mClaire/pname = gensym()),
                       x2 := (if (x.selector = nth) Call(nth,list(x.args[1],v))
                              else Call(x.selector,list(v))) in
                     (if (r % Call)
                        Let(var = v, value = r, arg = combine(x2, :=, combine(x2,p,y)))
                      else combine(x, :=, combine(x, p, y))),
              any combine(x, :=, combine(x, p, y))))

// **********************************************************************
// *   Part 3: reading expressions                                      *
// **********************************************************************

// reading the next compact expression - comments are ignored but they can
// be attached to the last read expression
//
nexte(r:meta_reader) : any
 -> let x := nextexp(r,false) in (if (x % Instruction) r.last_form := x, x)     // v3.3

// reading the next compact expression/ same
//
nextexp(r:meta_reader,str:boolean) : any
 -> (let n:integer := skipc(r) in
      (if (n = #/)) paren(r)
       else if (n = #/}) curly(r)
       else if (n = #/]) bracket(r)
 //      else if (n = #/>) angular(r)
       else if (n = #/|) (next(r), OR)
       else if (n = #/,) comma(r)
       else if (n = eof(r)) Serror("[153] eof inside an expression", nil)
       else if (n = #/;)
          (while (firstc(r) != eof(r) & firstc(r) != 10) next(r),
           if (firstc(r) = eof(r)) eof
           else (nb_line(r) :+ 1, next(r), nexte(r)))
       else if (n = #/#) read_escape(r)
       else if (n = #/`) Quote(arg = nexte(cnext(r)))
       else let y:any := unknown,
                x := (if (n = #/") Kernel/read_string(cnext(r).fromp)  ;"
                      else if (n = #/() readblock(r,nexte(cnext(r)), #/))
                      else if (n >= #/0 & n <= #/9) Kernel/read_number(r.fromp)         // read an int or a float
                      else if (n = #/{) readset(r, nexte(cnext(r)))                     // read a set
                      else (y := Kernel/read_ident(r.fromp),
                            if (y % string) y else nexti(r, y))) in
              (if (y % string)
                  (if extended_comment?(r,y as string)
				      extended_comment!(r,y as string)
				   else if str y
                   else nexte(r))         ; read a comment
               else (while (firstc(r) = #/[ | firstc(r) = #/. | firstc(r) = #/<)
	              (if (firstc(r) = #/<)
                        let y := nexte(cnext(r)) in
                          (if (x % class & firstc(r) = 62)
                            (cnext(r),
                             x := extract_class_call(x,list(Call(=,list(of,y)))),
                             x := nexti(r,x))
                           else Serror("[154] ~S<~S not allowed",list(x,y)))
                       else if (firstc(r) = #/[)
                        let l := nextseq(cnext(r), #/]) in
                         x := (if (x % class & x != type & l)
                                  extract_class_call(x,l)
                               else Call!(nth, x cons l))
                       else let y := Kernel/read_ident(cnext(r).fromp),
                                p := make_a_property(y)  in
                         (x := Call+(selector = p, args = list(x)),
                          if (p.reified = true) x := Call( read, list(x)))),
                     x))))

// reads a compact expression that starts with an ident
//
nexti(r:meta_reader, val:any) : any
 -> (if (firstc(r) = #/()
      (if (val % {exists, forall, some})
          let v :=  extract_variable(nexte(cnext(r))), %a2 := nexte(r),
		      %a3:any := any in
            (if (%a2 = in) (%a3 := nexte(r),
			    if (nexte(r) != OR)
                              Serror("[155] missing | in exists / forall",nil))
             else if (%a2 = comma(r)) cnext(r)
             else Serror("[156] wrong use of exists(~S ~S ...",list(v, %a2)),
             Exists( var = v, set_arg  = %a3,
                     arg = (let %bind := bind!(r,v), x := nexts!(r,#/)) in
                              (unbind!(r,%bind), x)),
                     other = (if (val = forall) true else if (val = exists) false else unknown)))
        else if (val = rule) (cnext(r), val)
        else readcall(r, val, unknown))
    else if (val = list & firstc(r) = #/{)
       let s := readset(r, nexte(cnext(r))) in
         case s
          (Image (put(isa,s,Collect), s),
           Select (put(isa,s,Lselect), s),
           any Serror("[157] ~S cannot follow list{", list(s)))
    else if ((case val (Call (val.selector = nth & val.args[1] = list),
                        any false)) & firstc(r) = #/{)
       let s := readset(r, nexte(cnext(r))),
           x := extract_of_type(val as Call) in
         case s
          (Image (put(isa,s,Collect), put(of,s,x), s),
           Select (put(isa,s,Lselect), put(of,s,x), s),
           any Serror("[157] ~S cannot follow list{", list(s)))
    else if ((case val (Call (val.selector = nth & val.args[1] = set),
                        any false)) & firstc(r) = #/{)
       let s := readset(r, nexte(cnext(r))),
           x := extract_of_type(val as Call) in
         case s
          (Image (put(of,s,x), s),
           Select (put(of,s,x), s),
           any Serror("[157] ~S cannot follow list{", list(s)))
    else if (firstc(r) = #/:) nextvariable(r, val)
    else if (firstc(r) = #/@)
       let %a1 := Kernel/read_ident(cnext(r).fromp) in
         (if not(%a1 % class)
             Serror("[158] wrong type in call ~S@~S", list(val, %a1)),
          if (firstc(r) = #/() readcall(r, val, %a1)
          else Serror("[159] missing ( after ~S@~S", list(val, %a1)))
    else val) 

// we have read the escape character #
//
read_escape(r:meta_reader) : any
 -> (if (firstc(cnext(r)) = #//)
       let val := firstc(cnext(r)) in (next(r), val)
    else if (firstc(r) = #/')
       make_function(string!(extract_symbol(Kernel/read_ident(cnext(r).fromp))))
    else if ((firstc(r) = #/i) & (firstc(cnext(r)) = #/f))
       (next(r), Zif)
    else Serror("[160] wrong use of special char #",nil))
        

// **********************************************************************
// *   Part 4: miscellaneous                                            *
// **********************************************************************

nextvariable(r:meta_reader, val:any) : any
 -> (if (val = <) (skipc(r), triangle)
     else Vardef(mClaire/pname = extract_symbol(val),
                 range = nexte(cnext(r))) )

// reads an expression, then the exact keyword e
//
nexts!(r:meta_reader, e:keyword) : any
 -> (let x := nexts(r, e) in
      (if not(stop?(firstc(r))) x
       else Serror("[161] Missing keyword ~S after ~S", list(e, x))))

// reads an expression, then the exact keyword e
//
nexte!(r:meta_reader, e:keyword) : any
 -> (let x := nexte(r) in
      (if (nexte(r) = e) x
       else Serror("[161] Missing keyword ~S after ~S", list(e, x))))

// ... exact separator
nexts!(r:meta_reader, e:integer) : any
 -> (let x := nexts(r, none) in
      (if (firstc(r) = e) (cnext(r), x)
       else Serror("[162] Missing separator ~S after ~S", list(char!(e), x))))

// ... keyword e or separator n. DOES NOT SKIP the last character
//
nexts!(r:meta_reader, e:keyword, n:integer) : any
 -> (let x := nexts(r, e) in
      (if (firstc(r) = n | not(stop?(firstc(r)))) x
       else Serror("[163] wrong separator ~S after ~S", list(char!(firstc(r)), x))))

// checks if s is an extended comment
//
extended_comment?(r:meta_reader,s:string) : boolean
  -> (let n := get(s,']') in
        (if (s[1] = EOS | s[1] != '[' | n = 0) false // v0.01
         else forall(i in (2 .. n) | s[n] != '[')))

// produce the equivalent extended comment
//
extended_comment!(r:meta_reader,s:string) : any
  -> (let i := get(s,']'),
          k := substring(s,"//",true),
          m := length(s),
          cx := firstc(r) in         // int code for the last char
       (print_in_string(),
	    while useless_c(integer!(s[m])) m :- 1,
		if (s[m] = ',') (cx := #/, , m :- 1),
		if (k = 0) k := m + 1,
        if (i = 3 & s[i] = '?')
           printf("assert(~I)", for j in ((i + 2) .. m) princ(s[j]))
        else printf("trace(~I,\"~I\\n\"~I)",
               for j in (2 .. (i - 1)) princ(s[j]),
               for j in ((i + 2) .. (k - 1)) princ(s[j]),
               (if (k + 3 <= m) (princ(","),
	        for j in ((k + 3) .. m) princ(s[j])))),
		let s2 := read(end_of_string()) in
		   (reader.nb_line :+ 1,            // the waiting '\n' is lost
                    flush(reader.fromp,cx),          // push back the int
                    s2)))


/***********************************************************************/
/**   metaCLAIRE                                        Yves Caseau    */
/**   readme.cl for meta (CLAIRE in CLAIRE)                            */
/**  Copyright (C) 1998-2013 Yves Caseau. All Rights Reserved.         */
/***********************************************************************/   
                 
This directory contains the first part of the meta-description of the CLAIRE system
It is composed of 3 modules:

/*************/
/**  Core   **/
/*************/

This is the claire-part of the microClaire library. It is defined by the following 
files:

- method:       first set of key methods, for evaluating methods and using slots
- object:       second set of key system methods, mostly for instantiation
- function:     the functions from the
- type:         the reflective definition of the type system

Here are the table of contents for each files + a short descriptopn

// *********************************************************************
// *  Cntents of method.cl                                             *
// *      Part 1: Lambda & Methods Evaluation                          *
// *      Part 2: Update methods                                       *
// *      Part 3: Management of definition(p)                          *
// *      Part 4: Matching Methods                                     *
// *********************************************************************
// *********************************************************************
// *  Contents of function.cl                                          *
// *   Part 1: Basics of pretty printing                               *
// *   Part 2: Methods for CLAIRE objects                              *
// *   Part 3: System Methods                                          *
// *   Part 4: Methods for Native entities                             *
// *********************************************************************
// *********************************************************************
// *  Contents of object.cl                                            *
// *   Part 1: Ask, debug & trace                                      *
// *   Part 2: Tables                                                  *
// *   Part 3: Demons & relations for the logic modules                *
// *   Part 4: Basics of Exceptions                                    *
// *********************************************************************
// *********************************************************************
// *  Contents of type.cl                                              *
// *    Part 1: Common Set Methods                                     *
// *    Part 2: definition of the type operators                       *
// *    Part 3: Interface methods                                      *
// *    Part 4: Lattice methods                                        *
// *    Part 5: Type methods                                           *
// *********************************************************************

/*****************/
/**  Language   **/
/*****************/

This module contains the "self-description" of the CLAIRE language, that is:
  - the classes for each syntactic construct
  - the self-print method : how to print each type of instruction
  - self-eval, how to evaluate = the CLAIRE definition of the interpreter

It is defined by the following four files:

- pretty:   this file contains the top of the "instruction" class hierarchy.
- call:     this file contains functional calls (ex-messages)
- control:  this file contains all major control structures
- define:   this file contains all definition & instanciation instructions

// *********************************************************************
// * Contents of pretty.cl:                                            *
// *      Part 1: unbound_symbol and variables                         *
// *      Part 2: lambdas                                              *
// *      Part 3: close methods for lattice_set instantiation          *
// *      Part 4: Pretty printing                                      *
// *********************************************************************
// *********************************************************************
// * Contents of call.cl                                               *
// *      Part 1: the basic object messages                            *
// *      Part 2: Basic structures                                     *
// *      Part 3: Specialized structures                               *
// *      Part 4: Functions on instructions                            *
// *********************************************************************
// *********************************************************************
// *  contents of control.cl                                           *
// *     Part 1: If, Do, Let                                           *
// *     Part 2: set control structures                                *
// *     Part 3: other control structures                              *
// *     Part 4: the constructs                                        *
// *********************************************************************
// **************************************************************************
// * Contents of define.cl:                                                 *
// *     Part 1: Definition instructions (Defobj, Defclass, Defmethod ...)  *
// *     Part 2: the instantiation macros                                   *
// *     Part 3: the useful stuff                                           *
// *     Part 4: the other macros                                           *
// **************************************************************************

/**************/
/**  Reader  **/
/**************/

This module contains the I/O library for CLAIRE: how to handle ports/files and
to read stuff in them. CLAIRE implements a syntactic reader very similar to the
one of LISP.
It is organized around 4 files:

- read:         this file contains the reader object and the top-level read functions
- syntax:       this file contains specialized reading methods
- file:         this file contains all that is related to files + top-level
- inspect:      this file contains the CLAIRE run-time tools: inspect, trace & debug

// **********************************************************************
// *  Content of read.cl:                                               *
// *   Part 1: The reader object                                        *
// *   Part 2: reading blocks                                           *
// *   Part 3: reading expressions                                      *
// *   Part 4: miscellaneous                                            *
// **********************************************************************
// **********************************************************************
// *  Content of syntax.cl                                              *
// *   Part 1: read operation expressions (<exp> <op> <exp>)            *
// *   Part 2: read control structures                                  *
// *   Part 3: read functional calls                                    *
// *   Part 4: read definitions                                         *
// **********************************************************************
// **********************************************************************
// * Contents of file.cl:                                               *
// *  Part 1: Utilities                                                 *
// *  Part 2: Loading                                                   *
// *  Part 3: Reading in a file/string & top-level                      *
// *  Part 4: The show & kill methods + macro-methods                   *
// **********************************************************************
// *********************************************************************
// * Contents of inspect.cl                                            *
// *      Part 1: Inspection                                           *
// *      Part 2: Trace                                                *
// *      Part 3: Debugger                                             *
// *      Part 4: Stepper                                              *
// *      Part 5: Profiler                                             *
// *********************************************************************//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| syntax.cl                                                   |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------
// this file contains specialized reading methods
// --------------------------------------------------------------

// **********************************************************************
// *  Content:                                                          *
// *   Part 1: read operation expressions (<exp> <op> <exp>)            *
// *   Part 2: read control structures                                  *
// *   Part 3: read functional calls                                    *
// *   Part 4: read definitions                                         *
// **********************************************************************

// **********************************************************************
// *   Part 1: read operation expressions (<exp> <op> <exp>)            *
// **********************************************************************

// who is an operation?
//
operation?(y:any) : boolean
 -> (y = as | y = := | y % operation | y = OR | y = % | y = add) 

// produce an expression from an operation
//
combine(x:any, y:any, z:any) : any
 -> (let p := operation!(x) in
      (if (p & precedence!(y) < precedence!(p))
          combine!(operand!(x, 1), p, combine(operand!(x, 2), y, z))
       else combine!(x, y, z)) )

combine!(x:any, y:any, z:any) : any
 -> (if (y = as) Cast(arg = x, set_arg = extract_type(z))
    else if (y = :=)
       case x
        (global_variable Gassign(var = x, arg = z),
         Call (if (case z (Call (((selector(z) = add) | (selector(z) = delete)) &
                                 (args(z)[1] = x) &
                                 (if (length(args(x)) = 1) multi?(selector(x))
                                  else if (x.selector = nth & length(x.args) = 2)
                                       multi?(x.args[1])))))
                   Call!(selector(z),
                         list(
                           (if (length(args(x)) = 1) selector(x) else args(x)[1]),
                           (if (length(args(x)) = 1) args(x)[1] else args(x)[2]),
                           args(z)[2]))
               else if (selector(x) = nth)
                  Call!(nth=, add(copy(args(x)), z))
               else if (length(args(x)) = 1)
                 let p := make_a_property(selector(x)), y := args(x)[1] in
                   (if (p = read & (case y (Call+ (y.selector.reified = true)))) Call!(write,list(y,z))
                    else Call!(write, list(p,y,z)))
               else Serror("[164] ~S cannot be assigned with :=", list(x))),
         Do let l := args(x), m := length(l),
                v := Variable(mClaire/pname = gensym()) in
              Let*(var = v, value = z,
                   arg = Do(list<any>{ 
                               Assign(var = l[i], arg = Call!(nth,list(v,i))) |
                               i in (1 .. m)})),
         any Assign(var = x, arg = z))
    else if (y = OR)
       case x (Or (add!(args, x, z), x), any Or(args = list(x, z)))
    else if (y = AND)
       case x (And (add!(args, x, z), x), any And(args = list(x, z)))
    else if (y = %) Call!(%,list(x, z))
    else DBregister(Call*(selector = y, args = list(x, z))))

// allows to treats Calls, Assigns, Gassign in an homogeneous way
//
operation!(x:any) : any
 -> (case x
     (Or OR,
      And AND,
      Assign :=,
      Gassign :=,
      Call let p := selector(x) in
             (if (x % Call* & operation?(p)) p
              else if (p = nth=) :=
              else if (p = write) :=),
      any false))

operand!(x:any, n:integer) : any
 -> (case x
     (Or (if (n = 1) Or(args = rmlast@list(copy(args(x))))
                        else last@list(args(x))),
      And (if (n = 1) And(args = rmlast@list(copy(args(x))))
                          else last@list(args(x))),
      Assign (if (n = 1) var(x) else arg(x)),
      Gassign (if (n = 1) var(x) else arg(x)),
      Call (if (selector(x) = write)
               (if (n = 2) args(x)[3]
                else Call!(args(x)[1],list(args(x)[2])))
            else if (selector(x) = nth=)
               (if (n = 2) last(args(x))
                else Call!(nth,rmlast(copy(args(x)))))
            else args(x)[n]),
      any false))

// precedence
//
precedence!(y:any) : integer
 -> (if (y = as) 0
    else if (y = :=) 100
    else if (y = AND) 1000
    else if (y = OR) 1010
    else precedence(y as operation))

// **********************************************************************
// *   Part 2: read control structures                                  *
// **********************************************************************

nextstruct(r:meta_reader, %first:keyword, e:keyword) : any
 -> (if (%first = let) readlet(r, e)
    else if (%first = when) readwhen(r, e)
    else if (%first = case) readcase(r, e)
    else if (%first = for)
       let %var := extract_variable(nexts!(r, in)),
           %set := nexte(r),
           %bind := bind!(r, %var),
           x := (if (firstc(r) = #/,) next(r), ; to remove later
                 For(var = %var, set_arg = %set, arg = nexts(r, e))) in
         (unbind!(r, %bind), x)
    else if (%first = while) While(test = nexte(r), arg = nexts(r, e), other = false)
    else if (%first = until) While(test = nexte(r), arg = nexts(r, e), other = true)
    else if (%first = try)
       let %a := nexts!(r, catch), %t := nexte(r) in
         Handle(test = %t, arg = %a, other = nexts(r, e))
    else %first)

// reads a let expression
//
readlet(r:meta_reader, e:keyword) : any
 -> (let %def := nexts!(r, in, #/,) in
      case %def
        (Assign let v := extract_variable(var(%def)),
                    %bind := bind!(r, v),
                    x := Let(var = v, value = get(arg, %def),
                            arg = (if (firstc(r) = #/,) readlet(cnext(r), e)
                                   else nexts(r, e))) in
                   (unbind!(r, %bind), x),
; I can't remember what this is ...
;         Defobj let v := extract_variable(var(%def)),
;                    %bind := bind!(r, v),
;                    x := Let(var = v, value = get(arg, %def),
;                            arg = (if (firstc(r) = #/,) readlet(cnext(r), e)
;                                   else nexts(r, e))) in
;                   (unbind!(r, %bind), x),
         Let*  (arg(%def) := readlet*(r,args(arg(%def) as Do),1,e), %def),
         Call[selector = write]
           let v1 := Variable(gensym(), any),
               v2 := Variable(gensym(), any),
               %a := args(%def), %e := nexts(r, e) in
              Let+(var = v1, value = Call+(selector = %a[1], args = list(%a[2])),
                   arg = Do(list<any>(%def,
                                 Let(var = v2, value = %e,
                                     arg = Do(list<any>(Call!(write,list(%a[1],%a[2],v1)), v2)))))),
         any Serror("[165] ~S is illegal after a let", list(%def))))
         


// recursive construction of the tail of a Let*
//
readlet*(r:meta_reader, l:list, n:integer, e:keyword) : any
 -> (if (n > length(l)) nexts(r, e)
    else let v := extract_variable(var(l[n])),
             %bind := bind!(r, v),
             x := Let(var = v, value = arg(l[n]), arg = readlet*(r,l,n + 1, e)) in
           (unbind!(r, %bind), x))


// reads a when expression
//
readwhen(r:meta_reader, e:keyword) : any
 -> (let %def := nexts!(r, in, #/,) in
      case %def
        (Assign let v := extract_variable(var(%def)),
                    %bind := bind!(r, v),
                    %a := nexts(r,else),
                    x := When(var = v, value = get(arg, %def), arg = %a,
                              other = (if stop?(firstc(r)) unknown
                                       else nexts(r, e))) in
                   (unbind!(r, %bind), x),
        any Serror("[165] ~S is illegal after a when", list(%def))))
         

// read an if
//
readif(r:meta_reader, e:integer) : any
 -> (let %a1 := nexte(r),
        %a2 := nexts(r, else) in
      If(test = %a1, arg = %a2,
         other =
           ((if (firstc(r) = #/, | firstc(r) = e) false
             else let x := nexte(r) in
                    (if (x = if) readif(r, e)
                     else if keyword?(x) nextstruct(r, x, none)
                     else loopexp(r, x, none, false))))))

// reads a member_of
//
readcase(r:meta_reader, e:keyword) : any
 -> (let %v := nexte(r) in
      (if (skipc!(r) != #/() Serror("[166] Missing ( after case ~S", list(%v)),
       let %x:Case := (Case(var = %v, args = list())), // v0.01
           %t:any := any in
         (while (firstc(r) != #/))
            (next(r),
             %t := extract_type(nexte(r)),
             put(args, %x, add(add(args(%x), %t), nexts(r, none))),
             if (not(stop?(firstc(r))) & not(stop?(skipc(r))))          ; because of toplevel ....
                Serror("[167] missing ) or , after ~S",list(%x))),
          next(r),
          if (e != none & not(stop?(skipc(r))) & nexte(r) != e)
             Serror("[161] missing ~S after ~S", list(e, %x)),
          %x)))

// if the expression begins with "{"
//
readset(r:meta_reader, %a1:any) : any
 -> (if (%a1 = curly(r)) (next(r), {})
    else (if keyword?(%a1) %a1 := nextstruct(r, %a1, none),
          let %a2 := nexte(r) in
            (if (%a2 = comma(r))
	       Kernel/cast!({dereference(u) | u in (%a1 cons nextseq(cnext(r), #/}))},{})
             else if (%a2 = curly(r))
               (next(r), Kernel/cast!(set(dereference(%a1)),{}))
             else if (%a2 = in)
                let v := extract_variable(%a1) in
                  Select(var = v, set_arg = nexte(r),
                         arg =
                           (let %bind := bind!(r, v),
                                x := ((if (nexte(r) != OR)
                                          Serror("[168] missing | in selection",nil)
                                       else nexts!(r, #/}))) in
                              (unbind!(r, %bind), x)))
             else if (%a2 = OR)
                let v := extract_variable(nexts!(r, in)) in
                  lexical_build(Image(var = v, set_arg = nexts!(r, #/}),
                                      arg = substitution(%a1,v,v)), list(v), 0)
             else if operation?(%a2)
                readset(r,
                        loopexp(r, combine(%a1, %a2, nexte(r)), none,
                                false))
             else Serror("[169] missing separation between ~S and ~S",
                         list(%a1, %a2)))))

dereference(x:any) : any
  -> (case x (unbound_symbol error("[170] cannot use ~S in a set constant",x),
             Variable error("[170] cannot use a variable (~S) in a set constant",x),
             any eval(x)))
			
			
// reads a sequence of exp. Must end with a e = ) | ] | }
//
nextseq(r:meta_reader, e:integer) : any
 -> (if (firstc(r) = e) (next(r), list())  // <yc:v0.01>
    else let x := nexts(r, none) in
           (if (firstc(r) = 10 & r.toplevel) skipc(r),         // v3.2.22
            if (firstc(r) = e) (next(r), list(x))
            else if (firstc(r) = #/,) x cons nextseq(cnext(r), e)
            else Serror("[171] Read the character ~S inside a sequence",
                        list(char!(firstc(r))))))

// read the next block: a sequence of exp. Must end with a e = ) | ] | }
//
readblock(r:meta_reader, x:any, e:integer) : any
 -> (skipc(r),
    if (x = paren(r)) list()
    else if (firstc(r) = #/,) Do!(x, readblock(r, nexte(cnext(r)), e))
    else if (firstc(r) = e) (cnext(r), x)
    else if stop?(firstc(r))
       Serror("[172] the sequence ...~S must end with ~A", list(x, char!(e)))
    else if (x = if) readblock(r, readif(r, e), e)
    else if (x = Zif) let %i := (readif(r,e) as If) in
                         readblock(r,(if eval(test(%i)) arg(%i) else other(%i)),e)
    else if (x = else) Serror("[173] Expression starting with else", nil)
    else if keyword?(x) readblock(r, nextstruct(r, x, none), e)
    else let y := loopexp(r, x, none, false) in
          (case y (Call* put(isa,y,Call)),
           readblock(r, y, e)))

Do!(x:any, y:any) : any
 -> (case y
     (Do (put(args, y, nth+(args(y), 1, x)), y),
      any Do(args = list<any>(x, y))))

// extract the type from a list<X> expression
extract_of_type(x:Call) : type
  -> let l := x.args in
       (if (length(l) > 2)
           let y := l[3] in
             (case y (List let z := y.args[1] in
                             (case z (Set extract_type(z.args[1] as type),
                                      any any)),
                      any any))
        else any)

// **********************************************************************
// *   Part 3: read functional calls                                    *
// **********************************************************************

// store the line number in debug mode
DBline[c:Call] : integer := 0

// this is a cool trick when operating in debug mode: we store the last evaluated
// call so we can tell very simply which last call triggered the error
//
DBregister(c:Call) : Call
 -> (if (system.Core/debug! >= 0) (Language/LastCall := c,DBline[c] := reader.nb_line),
     if (c.selector = store & length(c.args) = 1)        // otherwise it is ambiguous !
        let l := c.args in
          (if (l[1] % global_variable) l[1] := make_string(name(l[1]))),
     c)

Call!(p:property,l:list) : Call -> DBregister(Call(p,l))

// if the expression is a call -------------------------------------------
//
readcall(r:meta_reader, x:any, t:any) : any
 -> (let l := nextseq(cnext(r), #/)) in
      (if (x = printf) Printf(args = l)
       else if (x = error) Error(args = l)
       else if (x = assert)
           Assert(args = l, index = nb_line(r) , external = external(r))
       else if (x = trace) Trace(args = l)
       else if (x = branch) Branch(args = l)
       else if (x = quote) Quote(arg = (if l l[1]))
       else if (x = tuple) Tuple(args = l)
       else if (x = list) List(args = l)
       else if (case x (Call (x.args[1] = list)))     // ------ the 3 parameterized constructor
           List(of = extract_of_type(x as Call), args = l)
       else if (case x (Call (x.args[1] = array)))              // new in v3.2.16
           Array(of = extract_of_type(x as Call), args = l)
       else if (case x (Call (x.args[1] = set)))
           Set(of = extract_of_type(x as Call), args = l)
       else if (x % class & x inherit? Macro) let o := mClaire/new!(x) in (put(args,o,l), o)
       else if (x = set) Set(args = l)
       else if (x = return | x = break) Return(arg = (if l l[1] else true))
       else if (x % class)
          (if not(forall( y in l |
                          case y (Call (if (selector(y) = =)
                                       (args(y)[1] := make_a_property(args(y)[1]), true)))))
            let l2 := params(x as class),
                n :=  (case l2 (list length(l2), any 0)) in
             (if (length(l) = n)
                l := list{Call(selector = =, args = list(l2[i],l[i])) |
                          i in (1 .. n)}
              else Serror("[174] Wrong instantiation list ~S(~S...",list(x,list(l)))),
           Definition(arg = x, args = l))
       else if (x % Variable | (case x (global_variable x.range)))
           Call!(call,cons(x,(if l l else list(system))))
       else let p := make_a_property(x),
                l2 := ((if l l else list(system))) in
              (if known?(t) Super(selector = p, cast_to = t, args = l2)
               else Call!(p,l2))))


// **********************************************************************
// *   Part 4: read definitions                                         *
// **********************************************************************

// reads a definition (CLAIRE2 syntax)   - x and y are two expressions that have been read
//
nextdefinition(r:meta_reader,x:any,y:any,old?:boolean) : any
 -> (r.last_arrow := false,
     if (y = triangle) nextDefclass(cnext(r),x,old?)
     else if (y = :)
     let table? := (case x (Call (selector(x) = nth &
                                  args(x)[1] % (unbound_symbol U table)))),
         z := nexte(r), w := nexte(r) in
          (if (if table? (w = :=) else (w = arrow | w = =>)) nil         //v3.3
           else Serror("[149] wrong keyword (~S) after ~S",list(w,z)),
           nextmethod(r,x,z,table?,old?,( w = =>)))
    else if (y = ::)
     case x (Call let ru := nexte(r), z := nexts(r, =>) in
                   Defrule(ident = name(selector(x)), args = args(x),
                           arg = z,
                           body = (if (firstc(r) = #/)) (next(r),nil)
                                   else readblock(r, nexte(r), #/))) ),
             any nextinst(r,x))
    else if (y = arrow | y = =>)
     (r.last_arrow := (y = =>),
      //[3] ---- note: ~S - method's range is assumed to be void // x,
      nextmethod(r,x,void,false,old?,(y = =>)))       // v3.3 must be void
    else if (y = := & x % Vardef)
          Defobj(ident = mClaire/pname(x), arg = global_variable,
                 args = list(Call!(=, list(range, extract_type(range(x)))),     // v3.1.14
                             Call!(=, list(value, nexte(r)))))
     else Do(args = list<any>(x,y)))
    
    
nextmethod(r:meta_reader,x:any,y:any,table?:boolean,old?:boolean,inl?:boolean)  : any
  -> (let n := skipc(r),
          z := ( if old? readblock(r, nexte(r), #/])
                 else if (n = #/() (if toplevel(r) nexts(r, none)
                               else readblock(r, nexte(cnext(r)), #/)))
                 else nexte(r)),
          rs := Defmethod(arg = x, set_arg =  y, 
                          body = (if (z = let) readlet(r, None) else z), 
                          inline? = inl?) in
       (if table? put(isa,rs,Defarray), rs))

// reads an instantiation
//
nextinst(r:meta_reader, x:any) : any
 -> (case x
     (Variable (Defobj(ident = mClaire/pname(x), arg = global_variable,
                      args = list(Call(=, list(range, extract_type(range(x)))),  // v3.1.14
                                  Call(=, list(value, nexte(r)))))),
      Call let ru := nexte(r), z := nexts(r, =>) in
                   Defrule(ident = name(selector(x)), args = args(x),
                           arg = z,
                           body = (if (firstc(r) = #/)) (next(r),nil)
                                   else readblock(r, nexte(r), #/))) ),
      any let y := nexte(r) in
            (if (case x (global_variable unknown?(y))) y
			 else if (case y (Definition (arg(y) inherit? thing)))
                 Defobj(ident = extract_symbol(x), arg = arg(y),
                                args = args(y))
             else Defobj(ident = extract_symbol(x), arg = global_variable,
                         args =  list(Call(=,list(range, {})),
                                      Call(=,list(value, y)))))))


// reads a class Definition of the form C(p:t | p:t = v *)
// new in v2.5
nextDefclass(r:meta_reader,x:any,old?:boolean) : Defclass
 -> (skipc(r),
    let c := verify(class, Kernel/read_ident(r.fromp), Defclass),     // superclass
        y:Defclass :=                                    // create the Defclass
          (if (firstc(r) != #/() Defclass(arg = c, args = nil, forward? = true)
           else let l := nextseq(cnext(r), #/)) in
              (for y1 in l,
                 (if not(case y1
                          (Call (selector(y1) = = & args(y1)[1] % Vardef),
                           Vardef true,
                           any false))
                     Serror("[175] Wrong form ~S in ~S(~S)", list(y1, c, l))),
               Defclass(arg = c, args = l, forward? = false))),
        lp := nil,
        idt := (if (case x (Call selector(x) = nth))    // extract ident + list
                 let l := (x as Call).args in           // of parameters
                     (if (l[1] % class) lp := (l[2] as list)
                      else lp := list{make_a_property(y2) | y2 in cdr(l)},
                      extract_symbol(l[1]))
                 else extract_symbol(x)) in
        (if (old? & (skipc(r) != #/])) Serror("[176] Missing ] after ~S ", list(y))
         else if old? next(r),
         y.ident := idt,
         y.params := lp,
         y))


// end of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| types.cl                                                    |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// --------------------------------------------------------------------
// This file contains the definition of the CLAIRE type system (a true lattice).
// that is used both at compile- and at run-time.
// --------------------------------------------------------------------

// ******************************************************************
// *  Table of contents                                             *
// *    Part 1: Common Set Methods                                  *
// *    Part 2: definition of the type operators                    *
// *    Part 3: Interface methods                                   *
// *    Part 4: Lattice methods                                     *
// *    Part 5: Type methods                                        *
// ******************************************************************

claire/arg1 :: property()
claire/arg2 :: property()
claire/-- :: operation(precedence = precedence(..))

// *********************************************************************
// *   Part 1: Common Set Methods                                      *
// *********************************************************************

// ----------------------- useful methods ------------------------------
[finite?(self:type) : boolean
 -> case self
      (set true,
       list not({ t in self | not(finite?(t))}),
       class let n := self.open in (n >= 0 & n <= 2 & self != any),
       any false) ]


// making a bag from an abstract_set
[enumerate(self:any) : bag
 -> case self
      (bag self,
       array list!(self),
       integer make_set(self),
       collection set!(self),
       any error("[178] cannot enumerate ~S",self)) ]

// =type? is an operation (equality on types)
=type? :: operation()
[=type?(self:type,ens:type) : boolean -> (self <= ens & ens <= self)]

// finds the sort associated to a type
[sort!(x:type) : class
 -> case x
      (class sort!(x),
       any sort!(class!(x))) ]


// the membership membership for lattice_sets
[%(self:any,ens:class) : boolean
  -> if inherit?(owner(self),ens) true else false]

// an extension for %
[%type(x:any,y:any) : boolean
  -> if (x % type & y % set) exists(z in (y as set) | =type?(x,z))     // v3.2.28
     else (x % y) ]


// ****************************************************************
// *         Part 2: definition of the type operators             *
// ****************************************************************
Type <: type()

// union of two types ---------------------------------------------

// Disjonctive Union Axiom (DU): Each union (A U B) is stricly disjunctive:
//       (1) A ^B = 0
//       (2) x < A U B <=> x < A or x < B
// Producing disjunction union is a form of normalization (the previous notion
// of diustributivity was a lousy bug)
// DU Axiom is necessary to make <= and ^ easier to define
// This is achieved in the U method
Union <: Type(t1:type,t2:type)
self_print(self:Union) : void -> printf("(~S U ~S)", self.t1, self.t2)
finite?(self:Union) : boolean -> (finite?(self.t1) & finite?(self.t2))

// Intervals of integers ----------
Interval <: Type(arg1:integer,arg2:integer)
self_print(self:Interval) : void
 -> (printf("(~S .. ~S)", self.arg1, self.arg2))

finite?(self:Interval) : boolean -> true

// true constructor
--(x:integer,y:integer) : Interval
  -> (if (x <= y) (x .. y) as Interval // Interval(arg1 = x, arg2 = y)
      else error("[182] the interval (~S -- ~S) is empty",x,y))

// Parameterized class. -------------------------------------------
Param <: Type(arg:class,params:list,args:list)

[self_print(self:Param) : void
 -> if (length(self.params) = 1 & self.params[1] = of & self.args[1] % set)
       printf("~S<~S>", self.arg, (self.args[1] as set)[1])
    else printf("~S[~I]", self.arg,
           (for i in (1 .. length(self.args))
              (if (i != 1) princ(", "),
               printf("~S:(~S)", self.params[i], self.args[i])))) ]

finite?(self:Param) : boolean -> finite?(self.arg)

// subtype[X] ----------------------------------------------
// subtype[X] = {u in type | u <= t}
// for closure purposes, we add an arg Y -> Y inter st[X]
// Y can be any type class, but we forbid parametrisation on such classes !
// thus we can ensure that Y is a class
subtype <: Type(arg:class,t1:type)
[self_print(self:subtype) : void
   -> if (self.arg = type) printf("subtype[~S]", self.t1)
      else printf("~S[~S]", self.arg, self.t1) ]            // v3.2

finite?(self:subtype) : boolean -> (self.arg = set & finite?(self.t1))

// creates a subtype, with some normalization
// v3.2 list[t] -> subtype 
[nth(self:class,x:type) : type
 -> (if (self = set | self = list)  subtype(arg = self, t1 = x)
            ;   Param(arg = self, params = list(of),
            ;         args = list(subtype( arg = type, t1 = x)))
      else if not(self inherit? type) error("[177] subtyping of ~S not allowed",self)
      else subtype(arg =  (if (self = subtype) type else self), t1 = x)) ]

// create a Param with a list of parameters (constant properties) l1 and a list
// of types l2
[nth(self:class,l1:list,l2:list) : type
 -> // patch in v3.2.36  -> rather ugly ... the whole processing of X[Y..] pattern should be revised
    if ((self = list | self = set) & l2[1] % subtype)
        nth(self, (l2[1] as subtype).t1)   // this is the patch
    else if ((self = list | self = set) & l1[1] != of)
        error("[177] the subtyping expression ~S[~A] is not allowed",self,l1) // v3.2.36
    else Param(arg = self, params = l1, args = l2)]

// create a Param of the stack[X] kind
[param!(self:class,tx:type) : type
 ->  Param(arg = self, params = list(of), args = list(set(tx))) ]

// create the t[] param
[nth(self:type) : type
 ->  Param(arg = array, params = list(of), args = list(set(self))) ]

// tuple are types
finite?(self:tuple) : boolean -> forall(x in self | finite?(x))

// reference to a previous variable, not a type but a pattern -------
// index is the position of the stack of the referred type
// args is a list representing the path (a sequence of properties (parameters))
// a property is applied to the referred type
// if arg = true, the reference is the singleton containing the ref. value
// TODO check that arg is still used !
Reference <: Type(args:list,index:integer,arg:boolean = false)
self_print(self:Reference) : void -> printf("<ref:~S(ltype[~A])>",self.args,self.index)
get(self:Reference,y:any) : any
 -> (let l := self.args in
       (for i in (1 .. length(l)) y := (funcall(l[i] as property, y)), y))

// apply a reference to a type (l is args(self), passed for disambiguation)
@(self:Reference,l:list,y:any) : any
 -> (//[5] apply[@] ~S to ~S // self,y,
     for i in (1 .. length(l)) y := y @ (l[i] as property), y)

// type to set coercion  -------------------------------------------------

// new in v3.0.5 = use an interface method for type enumeration

// the default strategy is extensible: we look if there exists
// a proper definition that could be interpreted !
set!(x:collection) : set
  -> let m := (set! @ x.isa) in
       (if (domain!(m) != collection) (funcall(m,x) as set)
        else error("[178] cannot enumerate ~S",x))

size(x:collection) : integer
  -> let m := (size @ x.isa) in
       (if (domain!(m) != collection) (funcall(m,x) as integer)
        else length(set!(x)))                 // v3.2.34  -> makes the API simpler

(interface(size))

// set is needed for recursive def
set!(x:set) : set -> x
size(x:set) : integer -> length(x)

// set is needed for recursive def
size(x:list) : integer -> length(set!(x))

// class  -> return a read-only list  (v3.2)
set!(x:class) : set
  -> let rep := list() in
       (for c in x.descendents
          (if (inherit?(c,primitive) & c != boolean)
              error("[178] cannot enumerate ~S",c)
           else rep := rep /+ c.instances),
        set!(rep))

size(self:class) : integer
  -> let n:integer := 0 in
        (for x in self.descendents n :+ length(x.instances), n)


// Union
set!(x:Union) : set -> (set!(x.t1) /+ set!(x.t2))

size(x:Union) : integer
  ->  (if (x.t1 % Interval | x.t1 % set)  (size(x.t1) + size(x.t2))
       else length(set!(x)))

// interval
set!(x:Interval) : set
  -> --?(x.arg1, x.arg2)

size(self:Interval) : integer
  -> (self.arg2 + 1 - self.arg1)

// param
set!(x:Param) : set
  -> { y in set!(x.arg) | y % x}
size(x:Param) : integer -> length(set!(x))

// subtype
set!(x:subtype) : set
  ->  (if (x.arg = set) build_powerset(list!(set!(x.t1)))
       else error("[178] cannot enumerate ~S",x))
size(x:subtype) : integer
  -> (if (x.arg = set) ^2(size(x.t1))
      else error("[178] cannot enumerate ~S",x))

// tuple
set!(x:tuple) : set
  ->  let l := (x as list) in    // v3.0.54
        (if not(l) {{}}
         else let l1 := { list(y) | y in set!(l[1])} in
           (for n in (2 .. length(l))
             let l2 := set<any>() in
                (for z in set!(l[n])
                   for l3 in l1 l2 :add copy(l3) add z,
                 l1 := l2),
            l1))

size(l:tuple) : integer
  ->  (if not(l) 1
       else let m := size(l[1] as type) as integer in
          (for n in (2 .. length(l)) m :* size(l[n] as type),
           m))


// generic collection membership
// v3.2.24: this is extensible through the redefinition of %
[member?(x:any,y:type) : boolean
 -> case y
      (Union (member?(x, y.t1) | member?(x, y.t2)),
       Interval (case x (integer (y.arg1 <= x & x <= y.arg2), any false)),
       Param let n := 1,
                 l := y.args in
               (x % y.arg &
                not((for p:property in y.params
                       (if not(%type(funcall(p, x),l[n])) break(true) else n :+ 1)))),
       subtype ((if (y.arg = subtype) x % type else x % y.arg)
                 & (x <=t y.t1)),  // y.arg < type !
       tuple let n := length(y) in
               case x
                (tuple (length(x) = n &
                        forall( i in (1 .. n) | x[i] % y[i])),
                 any false),
       bag x % y,
       class x % y,
       Reference true,
       any let start := index!() in         // this is the extensibility part
             (push!(x),
              push!(y),
              let m := find_which(%, start, owner(x)) in
                (if (case m
                      (method
                         (length(m.domain) = 2 & m.domain[2] != any)))
                    (eval_message(%, m, start, true) as boolean)
                 else error("[179] (~S % ~S): not implemented!", x, y)))) ]

// the best class approximation
[class!(x:type) : class
 -> case x
      (class x,
       set (if (length(x) = 0) void
           else let rep := owner(x[1]) in
                  (for y in x rep := ((rep meet owner(y)) as class), rep)),
       Union (class!(x.t1) meet class!(x.t2)) as class,
       Interval integer,
       subtype (if (x.arg = subtype) any else x.arg),
       Param x.arg,
       Reference any,
       tuple tuple,
       any any) ]

// declarations
(ephemeral(Union),
 ephemeral(Param),
 ephemeral(Interval),
 ephemeral(subtype))

// ********************************************************************
// *                Part 3: Interface Methods                         *
// ********************************************************************

// there is a special restriction for + to specify the way the inheritance
// conflict should be solved
//U(self:set,ens:type) : type -> (case ens (set self /+ ens, any ens U self))

// the union makes a partial reduction to the normal form. The complete
// reduction is done by enumeration if needed during the type subsumption
// union is left-associative: A U B U C is represented by (A U B) U C  => never(t2(x:Union) % union)
// a union of intervals is ALWAYS disjoint
U(x:type,y:type) : type
 -> (case x
      (set case y (set x /+ y, any y U x),
       any (if (y <=t x) x
           else if (x <=t y) y
           else if (y % Union) (x U y.t1) U y.t2
           else if (case x (Interval (y % Interval)))
              (if (y.arg1 - 1 <= x.arg2 & x.arg1 <= y.arg1)       // adjacent
                  x.arg1 .. y.arg2
               else if (x.arg1 - 1 <= y.arg2 & y.arg1 <= x.arg1)
                  y.arg1 .. x.arg2
               else Union(t1 = x, t2 = y))
           else if (case x (Union y % Interval))
              let z := (x.t2 U y) in
                case z
                 (Union Union(t1 = (x.t1 U y), t2 = x.t2),
                  any x.t1 U z)
           else if (case x (Interval (y % set & (x.arg1 - 1 % y | x.arg2 + 1 % y))))
               let a := x.arg1, b := x.arg2 in    // new in v0.30
                 (if (a - 1 % y) a :- 1,
                  if (b + 1 % y) b :+ 1,
                  (a .. b) U y)
           else (if (y % set) y := {z in y | not(z % x)},
                 Union(t1 = x, t2 = y)))))


// the Interval construction method has a smart second-order type  - fix on v3.1.06
[..(x:integer,y:integer) :  type[(if (unique?(x) & unique?(y) & the(x) <= the(y))
                                    set(the(x) .. the(y))
                                  else subtype[integer]) ]
 -> if (x <= y) Interval(arg1 = x, arg2 = y) else {} ]

// exception
but :: operation()
but(s:any,x:any) : type[nth(bag,member(s))]      // <yc> 16/3/98
 -> (case s (list list{y in s | y != x},         // v3.3.36 (thanks to fxj)
             set copy(s) delete x, 
             any set!(s) delete x))

\ :: operation(precedence = U.precedence)
\(x:type,y:type) : set -> {z in x | not(z % y)}


// ******************************************************************
// *    Part 4: Lattice methods                                     *
// ******************************************************************

// glb operation ---------------------------------------------------
// should use type

// new in v3.0.60: we reintroduce a glb method
claire/glb :: operation(precedence = precedence(^), domain = type, range = type,     // v3.2.32 error !
                        mClaire/dispatcher = 4)

glb(x:set,y:type) : set -> { z in x | z % y}

glb(x:Union,y:type) : type ->  ((x.t1 glb y) U (x.t2 glb y))

glb(x:Interval,y:type) : type
 ->  (case y
       (class (if (integer <=t y) x else {}),
        set y glb x,
        Interval  (if (x.arg1 <= y.arg1)
                     (if (y.arg1 <= x.arg2)
                        (if (x.arg2 <= y.arg2) y.arg1 .. x.arg2
                         else y)
                      else {})
                   else y glb x),
        Union ((x glb y.t1) U (x glb y.t2)),    // v3.0.44
        any {}))

glb(x:class,y:type) : type
 -> (if (x.open = system.abstract & not(x.subclass)) { z in x | z % y}
     else if (x.open = system.abstract & not(x.instances))
        Uall(list{ (z glb y) | z:type in x.subclass})
     else case y (class x join y, any y glb x))

glb(x:Param,y:type) : type
 -> (case y
      (Param let c := (x.arg join y.arg),
                 lp := list!(set!(x.params /+ y.params)),
                 l := list<any>() in
               (for p in lp
                  let t := ((x @ p) glb (y @ p)) in
                    (if (t != {}) l :add t else (c := {}, break(true))),
                if (c != {}) Param(arg = c, params = lp, args = l)
                else {}),
       class let c := (x.arg join y) in
               (if (c != {}) Param(arg = c, params = x.params, args = x.args)
                else {}),
       any y glb x))

// notice that a param whose class is a type must use of (only parameter allowed!)
// the result is a subtype
glb(x:subtype,y:type) : type
 -> (case y
      (class (if ((x.arg join y) != {}) nth(x.arg join y, x.t1)       // v3.00.07
             else {}),
       Param (if ((x.arg join y.arg) != {})
                 param!(x.arg join y.arg, member(x) glb member(y))
              else {}),
       subtype (if ((x.arg join y.arg) != {})
                  let t := (x.t1 glb y.t1) in
                    (if (t != {}) nth(x.arg join y.arg, t) else {})
               else {}),
       any y glb x))

// set, Interval, list
glb(x:tuple,y:type) : type
 -> (case y
      (class (if (tuple inherit? y) x else {}),    // v2.4 BUG
       Param {},
       tuple tuple!((x as list) ^ (y as list)),    // ^ on lists implements Cartesian product ^
       subtype (if (y.arg = tuple) tuple!(list{ (z glb y.t1) | z in x})
               else {}),
       any y glb x))


// a reference is seen as "any"
glb(x:Reference,y:type) : type -> y

// this will be greatly simplified in a few minutes !
^(x:type,y:type) : type -> (x glb y)

// the old lattice_glb
[join(x:class,y:class) : type
 -> let l1 := x.ancestors, n1 := length(l1),
        l2 := y.ancestors, n2 := length(l2) in
       (if (n1 < n2)
           (if (l2[n1] = x) y else {})
        else if (l1[n2] = y) x
        else {}) ]

// for lists
[^(x:list,y:list) : list
 ->  let n := length(x),
         r:list := list() in
       (if (n = length(y))
           for i in (1 .. n)
             let z := (x[i] glb y[i]) in
               (if (z != {}) r :add z else (r := nil, break(true))),
        r) ]


// a combined union
Uall(l:list) : type -> (let rep := {} in (for x in l rep :U x, rep))

// ------------------- The inclusion operation ------------------------


<=t :: operation(precedence = precedence(<=), domain = type, range = boolean,
                 mClaire/dispatcher = 5)   // hand-made

// v3.2: extend from set to bags
<=t(s:bag,y:type) : boolean 
  -> let z := of(s) in
      (if (z != {}) (z <=t y)
       else forall( x in s | %type(x, y)))

// class
<=t(x:class,y:type) : boolean
 -> (case y
      (class y % x.ancestors,
       tuple false,
       Union (if (x.open = 0 & not(x.instances))
                not({ c in x.subclass | not(c <=t y)})
             else (x <=t y.t1 | x <=t y.t2)),
       set (if (x.open = 0 & not(x.subclass)) forall(u in x | u % y)
            else false),   // <yc>:2/98, 7:98
       any <=t@type(x,y)))

// Union
<=t(x:Union, y:type) : boolean  -> (x.t1 <=t y & x.t2 <=t y)

// Interval
<=t(x:Interval, y:type) : boolean
  -> (case y (Interval (y.arg1 <= x.arg1 & x.arg2 <= y.arg2),
              set ((set!(x) as bag) <=t y),
              Union (x <=t y.t1 | x <=t y.t2),
              class (integer inherit? y),
              any <=t@type(x, y)))

// subtype
<=t(x:subtype,y:type) : boolean
 -> (case y (Param <=t@type(x, y),
             subtype <=t@type(x, y),
             Union (x <=t y.t1 | x <=t y.t2),  // Requires DU Axiom
             any x.arg <=t y))

// Param is similar !
<=t(x:Param,y:type) : boolean
 -> (case y (Param <=t@type(x, y),
             subtype <=t@type(x, y),
             Union (x <=t y.t1 | x <=t y.t2),    // same
             any x.arg <=t y))

// Reference
<=t(x:Reference,y:type) : boolean -> true

// tuple : the only subtlety is the de-normalization of U within a tuple type
<=t(x:tuple,y:type) : boolean
  -> (when i := some(j in (1 .. length(x)) | x[j] % Union) in
               let ui := (x[i] as Union), x1 := copy(x), x2 := copy(x) in
                 (nth=(x1 as list,i,ui.t1),           // v3.1.14
                  nth=(x2 as list,i,ui.t2),
                  x1 <=t y & x2 <=t y)                   // lazy  normalization
      else case y
            (tuple (length(x) = length(y) &          // 3.1.16 <fxj>
                    forall( i in (1 .. length(x)) | x[i] <=t y[i])),
             Union (x <=t y.t1 | x <=t y.t2),    // same  v3.1.14
             any tuple <=t y))



// this is a generic ordering when y is a type Interval, a subtype or a Param
// x <= one such type is actually easy
<=t(x:type,y:type) : boolean
 -> (case y
      (Param (x <=t y.arg &
              forall(n in (1 .. length(y.params)) |
                     (x @ y.params[n] <=t y.args[n]))),
       Reference true,
       subtype (x <=t y.arg & member(x) <=t y.t1),               // new
       Interval false,
       any less?(x,y)))                                       // for extensibility !


// default order for types
<=(x:type,y:type) : boolean  -> (x <=t y)


// ******************************************************************
// *    Part 5: type methods                                        *
// ******************************************************************

// --------------------- extract tuple type information -------------

// extract a member type, that is a valid type for all members (z) of instances of
// the type x.This is much simpler in v3.0
[member(x:type) : type
 ->  case x
        (class (if (x = Interval) integer else any),
         Union member(x.t1) U member(x.t2),
         Interval {},
         Param member(x @ of),
         tuple Uall(x as list),
         subtype x.t1,
         set Uall(list{ (case y (list set!(y), type y, any {})) | y in x}),
         any {}) ]

// a simpler version (projection on bag subtypes)
// dumb code because it is used early in the bootstrap
[of_extract(x:type) : type
 -> let c := x.isa in
      (if (c = subtype) (x as subtype).t1
       else if  (c = Param)
         (if ((x as Param).params[1] = of)
             let y := ((x as Param).args[1] as type) in
               case y (set (y[1] as type),
                       subtype y.t1,
                       any any)
          else any)
       else any) ]


// --------------------- extract range information ------------------
// the method @ is used to extract the range information contained
// in a type. This method returns a type and is crucial for compiling !
[@(x:type,p:property) : type
 -> case x
      (class let r := (p @ x) in (if (r != false) (r as restriction).range else any),
       Param let i := get(x.params, p) in
               (if (i > 0) (x.args[i] as type) else x.arg @ p),
       Union (x.t1 @ p) U (x.t2 @ p),
       set Uall(list{ set(funcall(p, y)) | y in x}),     // v3.2.50: needs funcal vs get !
       any (class!(x) @ p)) ]

// useful type functions for the compiler
[unique?(x:type) : boolean
 -> case x
      (set size(x) = 1,
       class (x.open = 0 & size(x) = 1),
       any false) ]

// returns the unique element of the type
the(x:type) : any -> set!(x)[1]

// bitvector made easy
// v0.01: should not use set[0 .. 29] => burden on caller is too heavy
[integer!(s:set[integer]) : integer
 -> let n := 0 in
       (for y in s (if (y % (0 .. 29))  n :+ ^2(y)), n) ]

claire/make_set(x:integer) : set -> {i in (0 .. 29) | x[i]}

// asbtract coercion of a set into an interval
[abstract_type(xt1:set) : type
 -> let m1 := 1,
        m2 := 0 in
       (for x in xt1
          case x
           (integer (if (m1 > m2) (m1 := x, m2 := x)
                    else if (x > m2) m2 := x
                    else if (x < m1) m1 := x),
            any (m1 := 1, m2 := 0, break(true))),
        m1 .. m2) ]

// abstract interpretation of integer arithmetique
[abstract_type(p:operation,xt1:type,xt2:type) : type
 -> case xt1
      (set (if (xt1 != {}) abstract_type(p, abstract_type(xt1), xt2) else xt1),
       Interval case xt2
                (Interval
                   (if (p = +)
                       (xt1.arg1 + xt2.arg1) .. (xt1.arg2 + xt2.arg2)
                    else if (p = -)
                       (xt1.arg1 - xt2.arg2) .. (xt1.arg2 - xt2.arg1)
                    else integer),
                 set (if (xt2 != {}) abstract_type(p, xt1, abstract_type(xt2))
                     else xt2),
                 Union abstract_type(p, xt1, xt2.t1) U abstract_type(p, xt1, xt2.t2),
                 any integer),
       Union abstract_type(p, xt1.t1, xt2) U abstract_type(p, xt1.t2, xt2),
       any integer) ]

// we create some types that we need
(set_range(subclass, class, set<class>),
 set_range(ancestors, class, list<class>),
 set_range(descendents, class, set<class>),
 set_range(definition, property, list<restriction>),
 set_range(restrictions, property, list<restriction>),
 set_range(domain,restriction,list<type>),
 set_range(slots, class, list<slot>))

// a useful second ortder type
first_arg_type(x:type,y:type) : type -> x
first_arg_type(x:type,y:type,z:type) : type -> x
second_arg_type(x:type,y:type) : type -> y
meet_arg_types(x:type,y:type) : type -> (x U y)
first_member_type(x:type,y:type) : type -> member(x)  // v3.3.10

// we place here all methods that require second order types !!!!
//nth_get(a:array,n:integer) : type[member(a)] -> function!(nth_get_array)
nth(self:array,x:integer) : type[member(self)]
 -> (if (x > 0 & x <= length(self)) nth_get(self,x)
     else error("[180] nth[~S] out of scope for ~S", x, self))
make_array(i:integer,t:type,v:any) : type[ (if unique?(t) (the(t))[] else array)]
 -> function!(make_array_integer,NEW_ALLOC)
 
make_list(n:integer,t:type,x:any) : type[ (if unique?(t) list[the(t)] else list)]
  -> (cast!(make_list(n,x),t) as list)
 
make_set(self:array<X>) : type[(if (X = any) set else set<X>)]
  -> set!(list!(self))
list!(a:array<X>) : type[(if (X = any) list else list<X>)]
 -> function!(list_I_array, NEW_ALLOC)
array!(a:list<X>) : type[(if (X = any) array else array<X>)]
 -> function!(array_I_list, NEW_ALLOC)      // v3.0.72

set!(l:list<X>) : type[(if (X = any) set else set<X>)]  // v3.1.06
  -> function!(set_I_bag,NEW_ALLOC,SAFE_RESULT)
list!(l:set<X>) : type[(if (X = any) list else list<X>)]
  -> function!(list_I_set,NEW_ALLOC,SAFE_RESULT)


// new in v3.0.60 : second-order type for copy
(for r in copy.restrictions (r as method).Kernel/typing := Id,
 for r in empty.restrictions (r as method).Kernel/typing := Id,
 for r in sort.restrictions (r as method).Kernel/typing := second_arg_type,
 for r in /+.restrictions (r as method).Kernel/typing := meet_arg_types,
 // here we add some simple second orders
 (nth_get @ array).Kernel/typing := first_member_type,
 for r in nth+.restrictions (r as method).Kernel/typing := first_arg_type,
 for r in add.restrictions
    (if (length(r.domain) = 2) (r as method).Kernel/typing := first_arg_type),
 for r in delete.restrictions
    (if (length(r.domain) = 2) (r as method).Kernel/typing := first_arg_type))

